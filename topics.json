{"success":true,"data":[{"id":"5bd4772a14e994202cd5bdb7","author_id":"504c28a2e2b845157708cb61","tab":"share","content":"<div class=\"markdown-text\"><p>2018年10月27日晚上，突然收到服务器不能访问的告警通知，拜托了狼叔 <a href=\"/user/i5ting\">@i5ting</a> 帮忙看看，结果登不上也ping不通。\n后来收到短信，发现是被ucloud封了，短信内容如下：</p>\n<blockquote>\n<p>【UCloud】尊敬的UCloud用户，您的IP：123.59.77.142  存在URL ：<a href=\"https://cnodejs.org/topic/57239bce5a26c4a841ecbf01\">https://cnodejs.org/topic/57239bce5a26c4a841ecbf01</a> （详细信息请查看邮箱）包含违禁内容（包括但不限于翻墙等），违反了国家有关法律法规。目前依主管单位要求，对您的IP予以封停，请您尽快处理违规内容。待处理完成后请联系技术支持重新开启业务。[4000188113]</p>\n</blockquote>\n<p>然后联系了ucloud的客服，一下就打通了，对方态度挺好处理问题也快。ucloud说是运营商那边封的，不是他们的检测机制。所以需要联系运营商解决。\n考虑到各位亲爱的网友们的行为我无法控制，那么一直跟越来越严格的审查系统对抗只会让自己疲惫，所以我就站点迁到国外。来到了aws jp。</p>\n<p>我大致测了测，电信和移动的访问速度非常快，100ms以内，联通会慢一点，400ms以内吧。</p>\n<p>建议翻墙访问。</p>\n</div>","title":"服务器迁移至 aws 日本机房","last_reply_at":"2019-02-22T00:37:11.946Z","good":false,"top":true,"reply_count":143,"visit_count":15111,"create_at":"2018-10-27T14:33:14.694Z","author":{"loginname":"alsotang","avatar_url":"https://avatars1.githubusercontent.com/u/1147375?v=4&s=120"}},{"id":"5c71072533b0b629ac84481d","author_id":"5711b41a238ae0ac1e3a6a27","tab":"share","content":"<div class=\"markdown-text\"><p>输入我的邀请码 YXR75ZX 来获得三个月的蓝灯专业版！立即下载 <a href=\"https://github.com/getlantern/forum\">https://github.com/getlantern/forum</a></p>\n</div>","title":"不翻墙的程序员不是好程序员","last_reply_at":"2019-02-23T09:00:12.020Z","good":false,"top":false,"reply_count":1,"visit_count":96,"create_at":"2019-02-23T08:41:09.652Z","author":{"loginname":"sk-blog","avatar_url":"https://avatars3.githubusercontent.com/u/10380760?v=4&s=120"}},{"id":"5c70fd5ee1a81129a7ad9e41","author_id":"5b04264e4c0dc41665d141ce","tab":"share","content":"<div class=\"markdown-text\"><p>SB</p>\n</div>","title":"汪玉星111111","last_reply_at":"2019-02-23T07:59:26.671Z","good":false,"top":false,"reply_count":0,"visit_count":55,"create_at":"2019-02-23T07:59:26.671Z","author":{"loginname":"qinran0423","avatar_url":"https://avatars2.githubusercontent.com/u/25677854?v=4&s=120"}},{"id":"5c70ea11e1a81129a7ad9de8","author_id":"5a729a709d371d4a059ef083","tab":"ask","content":"<div class=\"markdown-text\"><p>今天在给koa项目引入<a href=\"/user/types\">@types</a>/koa的时候发现，它在ctx上没有标注body…但既有项目上有大量通过ctx.body取请求体里值的代码\n修改<a href=\"/user/types\">@types</a>/koa 的index.d.ts是很容易，问题是重新安装依赖的时候并不会是修改后的版本，而直接保存依赖包又比较不合理\n所以想在 nodemodules 外新建一个typing来保存koa的类型声明…\n然后，我发现，单纯的把类型依赖移进去，并通过指定\n（路径被转义了…凑合看…）</p>\n<pre class=\"prettyprint language- js\"><code>{\n    &quot;compilerOptions&quot;: {\n        &quot;typeRoots&quot; : [\n            &quot;.&#x2F;typings&#x2F;[@types](&#x2F;user&#x2F;types)&#x2F;&quot;,\n            &quot;.&#x2F;node_modules&#x2F;[@types](&#x2F;user&#x2F;types)&#x2F;&quot;\n        ]\n    },\n}\n\n</code></pre><p>是读不出来的，貌似是koa的包里有指明存在声明文件的话会在哪？或者是默认规则？\n有办法，在nodemodules外单独维护第三方依赖包的类型声明文件么？</p>\n</div>","title":"有办法在node_modules 外保存依赖包的@types文件的同时保证解析器能读到这个类型说明吗？","last_reply_at":"2019-02-23T07:52:58.436Z","good":false,"top":false,"reply_count":1,"visit_count":67,"create_at":"2019-02-23T06:37:05.970Z","author":{"loginname":"w46245","avatar_url":"https://avatars1.githubusercontent.com/u/13960592?v=4&s=120"}},{"id":"5c70f750e1a81129a7ad9e24","author_id":"5b04264e4c0dc41665d141ce","tab":"share","content":"<div class=\"markdown-text\"><p>aksjdlkjsadlkjsaldjsakldjaskdjaskldjaskldjskladjaskldjkasldjlas</p>\n</div>","title":"222wwwwwwww","last_reply_at":"2019-02-23T07:33:36.717Z","good":false,"top":false,"reply_count":0,"visit_count":63,"create_at":"2019-02-23T07:33:36.717Z","author":{"loginname":"qinran0423","avatar_url":"https://avatars2.githubusercontent.com/u/25677854?v=4&s=120"}},{"id":"5c6cef4de1a81129a7ad8a96","author_id":"5a729a709d371d4a059ef083","tab":"ask","content":"<div class=\"markdown-text\"><p>比如一个请求还没结束的时候进来了第二个请求，这个时候日志就会重叠…\n我能想到的，比如，请求进入的时候运行日志记录开始，后续的日志记录到一个数组里，结束的时候一次性写到文件里去，保证一块一块的…\n想知道有没有别的办法</p>\n</div>","title":"起http服务比如koa时有并发导致日志的顺序很乱有什么解决方案么？","last_reply_at":"2019-02-23T06:29:39.158Z","good":false,"top":false,"reply_count":7,"visit_count":357,"create_at":"2019-02-20T06:10:21.628Z","author":{"loginname":"w46245","avatar_url":"https://avatars1.githubusercontent.com/u/13960592?v=4&s=120"}},{"id":"5c203e7776c4964062a1ce04","author_id":"5129b03cdf9e9fcc58f3673c","tab":"share","content":"<div class=\"markdown-text\"><p>各位小哥哥小姐姐，分享个圣诞桌面祝大家圣诞快乐\n<a href=\"http://desktop.bittyos.com/?share=46fada80-f9fc-11e8-a653-373a5689e1b3\">http://desktop.bittyos.com/?share=46fada80-f9fc-11e8-a653-373a5689e1b3</a>\n<img src=\"//static.cnodejs.org/FrFmzitH9OluHpCz3xAZlMPwHjww\" alt=\"QQ截图20181224103521.jpg\"></p>\n<p>唯美三生三世主题的桌面\n<a href=\"http://desktop.bittyos.com/?share=6d4ff590-33fd-11e9-a653-373a5689e1b3\">http://desktop.bittyos.com/?share=6d4ff590-33fd-11e9-a653-373a5689e1b3</a>\n<img src=\"//static.cnodejs.org/FvaDCaeEjCoFOpEF0vQtem7LAfKr\" alt=\"QQ截图20190218140012.png\"></p>\n</div>","title":"圣诞桌面 Merry Christmas & 唯美三生三世桌面","last_reply_at":"2019-02-23T05:18:26.595Z","good":false,"top":false,"reply_count":12,"visit_count":1310,"create_at":"2018-12-24T02:03:35.105Z","author":{"loginname":"yunfei","avatar_url":"https://avatars1.githubusercontent.com/u/6891001?v=4&s=120"}},{"id":"5c6fc2d133b0b629ac84454f","author_id":"5ab1e8e8e7b166bb7b9ecca9","tab":"ask","content":"<div class=\"markdown-text\"><h2>问题</h2>\n<p>2个表相关联，一定要在2个表中的定义associate吗，\n如下user表，post表，\n一个用户可以有多篇文章，一篇文章只能属于一个用户</p>\n<pre class=\"prettyprint\"><code>app.model.User.hasMany(app.model.Post, { as: &#x27;posts&#x27; });\n</code></pre><pre class=\"prettyprint\"><code>app.model.Post.belongsTo(app.model.User, { as: &#x27;user&#x27;, foreignKey: &#x27;user_id&#x27; });\n</code></pre><h2>user表</h2>\n<pre class=\"prettyprint\"><code>  const User = app.model.define(&#x27;user&#x27;, {\n    id: {\n      type: INTEGER,\n      primaryKey: true,\n      autoIncrement: true,\n    },\n    name: STRING(30),\n    age: INTEGER,\n    created_at: DATE,\n    updated_at: DATE,\n  });\n\n  User.prototype.associate = function() {\n    app.model.User.hasMany(app.model.Post, { as: &#x27;posts&#x27; });\n  };\n</code></pre><h2>post</h2>\n<pre class=\"prettyprint\"><code>  const Post = app.model.define(&#x27;post&#x27;, {\n    id: {\n      type: INTEGER,\n      primaryKey: true,\n      autoIncrement: true,\n    },\n    title: STRING(30),\n    content: STRING(255),\n    user_id: INTEGER,\n    created_at: DATE,\n    updated_at: DATE,\n  });\n\n  Post.associate = function() {\n    app.model.Post.belongsTo(app.model.User, { as: &#x27;user&#x27;, foreignKey: &#x27;user_id&#x27; });\n  };\n</code></pre></div>","title":"Sequelize联表查询的问题","last_reply_at":"2019-02-23T02:37:43.045Z","good":false,"top":false,"reply_count":2,"visit_count":112,"create_at":"2019-02-22T09:37:21.267Z","author":{"loginname":"1134506391","avatar_url":"https://avatars2.githubusercontent.com/u/30287598?v=4&s=120"}},{"id":"5c6f5f3c33b0b629ac8441a0","author_id":"58d83c586f8b9bf02d1d0b1d","tab":"ask","content":"<div class=\"markdown-text\"><p>rt</p>\n</div>","title":"为什么微软这么厉害的公司，写出来的浏览器这么一般","last_reply_at":"2019-02-23T00:43:30.987Z","good":false,"top":false,"reply_count":5,"visit_count":517,"create_at":"2019-02-22T02:32:28.627Z","author":{"loginname":"ResJay","avatar_url":"https://avatars0.githubusercontent.com/u/26635410?v=4&s=120"}},{"id":"5c64daa8f53f161dbaeb3826","author_id":"599e2723ebaa046923a826f0","tab":"ask","content":"<div class=\"markdown-text\"><p>以前在vscode上写的项目是可以的，像这样：\n<img src=\"//static.cnodejs.org/FjypwT71XPgj6k0y516EAp57Sa0W\" alt=\"image.png\">\n然后用起来：\n<img src=\"//static.cnodejs.org/FtePjhuATXOaQ243bqug1EvBpTEm\" alt=\"image.png\">\n有提示，然后可以根据提示去写代码，但是后来写了另外的项目，基本这个部分是抄袭的，然而竟然检测不出，导致：\n<img src=\"//static.cnodejs.org/FlZclcLrjJN2aIhsynebDNSIH3ev\" alt=\"image.png\">\n这样，虽然可以用，但是好不爽啊，在ws上是没问题的。\n我花了时间对比了两个项目的各种设置和vscode的设置，没找出问题。\n各位可有类似经验？可否拯救一下小弟。</p>\n</div>","title":"求助：关于在vscode上，不能提示vue中import js文件的问题","last_reply_at":"2019-02-22T16:26:11.501Z","good":false,"top":false,"reply_count":3,"visit_count":656,"create_at":"2019-02-14T03:04:08.831Z","author":{"loginname":"HobaiRiku","avatar_url":"https://avatars2.githubusercontent.com/u/26238803?v=4&s=120"}},{"id":"5c6e12e9e1a81129a7ad910c","author_id":"5c529dd5e6aaad2ea76de3a2","tab":"ask","content":"<div class=\"markdown-text\"><p>我将favicon.ico放在了public目录中，然后直接使用<code>js\\n &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; \\n</code>，用浏览器右键open in new tab能打开，但是图标并不显示，在network里也没看到关于favicon.ico的请求。然后我下载了serve-favicon，<code>js\\n var favicon = require('serve-favicon'); app.use(favicon(__dirname + '/public/favicon.ico'));\\n</code>并不生效，请大佬帮忙看一下，非常感谢</p>\n</div>","title":"请问express4中favicon设置为什么没生效？","last_reply_at":"2019-02-22T15:41:45.913Z","good":false,"top":false,"reply_count":3,"visit_count":220,"create_at":"2019-02-21T02:54:33.677Z","author":{"loginname":"pc937466839","avatar_url":"https://avatars2.githubusercontent.com/u/26129458?v=4&s=120"}},{"id":"5c6ba967b8913c5110b0c3fe","author_id":"5b7cc310632c7f422e5b8066","tab":"ask","content":"<div class=\"markdown-text\"><p>这都node11，12版本了，找了一圈还是没有简单直接的用import方法，什么时候能原生支持啊</p>\n</div>","title":"node中import老大难问题","last_reply_at":"2019-02-22T14:35:01.471Z","good":false,"top":false,"reply_count":21,"visit_count":738,"create_at":"2019-02-19T06:59:51.500Z","author":{"loginname":"DuJiming","avatar_url":"https://avatars2.githubusercontent.com/u/36750680?v=4&s=120"}},{"id":"5c6cfdf5e1a81129a7ad8b7f","author_id":"5c663d23f53f161dbaeb3de4","tab":"ask","content":"<div class=\"markdown-text\"><p><strong>是《Nodejs in action》这本书吗</strong></p>\n<h4>新手求入门书籍和进阶书籍</h4>\n<blockquote>\n<p>先找到对的书， 然后拜读不是吗</p>\n</blockquote>\n<p><strong><em>求一下中文版pdf链接</em></strong></p>\n</div>","title":"狼叔说的 把《node in action》看五遍， 然后去写代码,  是认真的吗","last_reply_at":"2019-02-22T13:18:13.005Z","good":false,"top":false,"reply_count":23,"visit_count":1275,"create_at":"2019-02-20T07:12:53.928Z","author":{"loginname":"nelhu","avatar_url":"https://avatars3.githubusercontent.com/u/24311105?v=4&s=120"}},{"id":"5b8e207937b3005a0b0e6b50","author_id":"5b8e1ee0bf116a8c0e4257b4","tab":"ask","content":"<div class=\"markdown-text\"><p>怎么才能真正学好node.js,东西太多了，老忘记怎么办？</p>\n</div>","title":"如何才能学好node.js","last_reply_at":"2019-02-22T11:20:55.639Z","good":false,"top":false,"reply_count":33,"visit_count":4669,"create_at":"2018-09-04T06:04:41.390Z","author":{"loginname":"kouxiang2008","avatar_url":"https://avatars1.githubusercontent.com/u/42954282?v=4&s=120"}},{"id":"5b5e78f5673571454c633cea","author_id":"5b56866ae740336c7bedb345","tab":"share","content":"<div class=\"markdown-text\"><p><strong>koa2实战项目介绍（真全栈）：</strong></p>\n<p><strong>Nodejs+koa2实战视频教程</strong>从零开始一步一步让你学会Koa基础以及用用<strong>Koa开发项目</strong>，本教程涉及 用户权限判断 、<strong>验证码</strong> 、分页、多级分类、<strong>ueditor可视化富文本编辑器</strong>、图片上传、<strong>底层DB库封装</strong>、<strong>扩展art-template的核心方法、<strong>ajax改变状态、ajax排序、以及赠送的</strong>Socket.io机器人</strong> 、Socket.io多人聊天室、<strong>Socket.io群聊</strong>、前后端分离 <strong>RESTful API Api</strong>接口、购买域名 服务器、域名备案、<strong>nginx负载均衡</strong>、<strong>域名解析部署nodejs程序</strong>、Nodejs进程管理器pm2模块、Koa操作<strong>mysql数据库</strong></p>\n<p><strong>地址：</strong> <a href=\"https://www.itying.com/goods-800.html\">Koa2实战视频教程下载地址点我</a></p>\n<p><strong>2018 Nodejs+Koa2入门实战视频教程百度网盘下载地址（41讲免费基础下载地址）：</strong></p>\n<p><a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w</a></p>\n</div>","title":"Nodejs+koa2实战视频教程【87讲】--Koa2+Nodejs+MongoDb打造企业级CMS前后端全栈项目实战视频教程","last_reply_at":"2019-02-22T10:39:43.831Z","good":false,"top":false,"reply_count":67,"visit_count":13611,"create_at":"2018-07-30T02:33:25.113Z","author":{"loginname":"songsunli","avatar_url":"https://avatars1.githubusercontent.com/u/41601667?v=4&s=120"}},{"id":"5c6e814f33b0b629ac843e87","author_id":"564582ec5e7412b625b8bf16","tab":"ask","content":"<div class=\"markdown-text\"><p>在express框架下，结合七牛云，实现ueditor编辑器的中的所有文件上传到七牛空间中，能开发的小伙伴私信，任务截止时间：明天（22号）早上9点前交付。能完成的小伙伴私信，带上你的报价。\n长期任务兼职，微信 c35353。加我请备注 cnode</p>\n</div>","title":"【兼职任务】 express + ueditor + 七牛云","last_reply_at":"2019-02-22T08:17:39.483Z","good":false,"top":false,"reply_count":1,"visit_count":331,"create_at":"2019-02-21T10:45:35.933Z","author":{"loginname":"RajanZhan","avatar_url":"https://avatars1.githubusercontent.com/u/15818327?v=4&s=120"}},{"id":"5c6f5cab33b0b629ac844170","author_id":"5c6f5c42e1a81129a7ad9809","tab":"share","content":"<div class=\"markdown-text\"><p>NEO DAPP全球区块链应用开发挑战赛于北京时间2018年12月21日正式拉开序幕，此次大赛旨在发掘与聚集更多区块链开发者，探索各行各业与区块链的结合方式，促进区块链应用领域的继续创新，从而催生出更多优秀的区块链应用，形成一个强大的区块链应用开发者生态。</p>\n<p>为更好地激励技术开发者加入这场技术挑战赛，我们将在全球范围内拿出30万奖金，共设16个奖项以此激励在大赛中脱颖而出的优秀技术团队们。\n<img src=\"//static.cnodejs.org/FkI6EFfMPP6kOh6JUIZLUPIP8fUr\" alt=\"image.png\">\n时间截止至3.31日\n评选标准\n● 产品逻辑：整个产品设计的运行逻辑 （15%）</p>\n<p>● 区块链应用点：与区块链结合的匹配度和上链逻辑（15%）</p>\n<p>● 技术开发：技术实现的性能和效果（20%）</p>\n<p>● 产品视觉：视觉设计以及呈现的效果（10%）</p>\n<p>● 商业模式：是否具备市场应用价值和可行的商业模式（10%）</p>\n<p>● 人气值：采用用户投票方式收集人气，得票即为人气值（10%）</p>\n<p>● 开发进度：对应时间节点的开发进度和作品完整程度（20%）\n报名方式\n扫描二维码\n<img src=\"//static.cnodejs.org/FkZS9Bnmz0ZqDM884ESYRj-TADVG\" alt=\"image.png\">\n或者联系微信：f18268579344和公众号NEONEXT\n添加微信时，记得备注next哦！</p>\n</div>","title":"“NEO DAPP全球区块链应用开发挑战赛”报名进行中","last_reply_at":"2019-02-22T08:15:09.426Z","good":false,"top":false,"reply_count":1,"visit_count":171,"create_at":"2019-02-22T02:21:31.002Z","author":{"loginname":"HVOD","avatar_url":"https://avatars2.githubusercontent.com/u/47730911?v=4&s=120"}},{"id":"5c458c396955112b99437594","author_id":"54edd6faf08635a279d18cff","tab":"ask","content":"<div class=\"markdown-text\"><p>谁有收藏2019前端技能树这样子的图，能否发我一下，多谢-V-</p>\n</div>","title":"谁有收藏2019前端技能树这样子的图，能否发一下","last_reply_at":"2019-02-22T07:54:08.444Z","good":false,"top":false,"reply_count":9,"visit_count":1738,"create_at":"2019-01-21T09:09:13.218Z","author":{"loginname":"nqdy666","avatar_url":"https://avatars2.githubusercontent.com/u/5211893?v=4&s=120"}},{"id":"5c6fa32133b0b629ac8443d6","author_id":"573212537abbbd520cb244b3","tab":"ask","content":"<div class=\"markdown-text\"><p><a href=\"https://jsbin.com/pihujok/edit?html,css,output\">https://jsbin.com/pihujok/edit?html,css,output</a></p>\n<p>我现在用的是 css3 循环动画,  然后每次更新最后一条数据.\n效果不太理想, 有更好的办法么?</p>\n</div>","title":"这种弹幕数据如何渲染?","last_reply_at":"2019-02-22T07:22:09.319Z","good":false,"top":false,"reply_count":0,"visit_count":185,"create_at":"2019-02-22T07:22:09.319Z","author":{"loginname":"dlyt","avatar_url":"https://avatars0.githubusercontent.com/u/18431616?v=4&s=120"}},{"id":"5c6f7f0e33b0b629ac8442e5","author_id":"5c6f777433b0b629ac8442b6","tab":"ask","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FiHpigZPIp2AvvA2CQHmtvxTWyL4\" alt=\"Screenshot_20190222-123210.png\"></p>\n<p><a href=\"https://photos.google.com/share/AF1QipNiK_IQM4HrtI5_9uzfJmkC1-8-tYJs4BlilVm-3M2PoRud3YoJ2umWvKE3yQ45Ig?key=YzhoeWg1c1UwZXVyaUQ3QWNiOC1yX1N2YWlSNl9B\">类似视频</a></p>\n<h5>输入：abcdefg</h5>\n<p>第一次backspace，增加abcdef，\n下一次，abcde</p>\n<h5>xterm 目前不支持移动设备</h5>\n<p><a href=\"https://github.com/xtermjs/xterm.js/issues/675\">https://github.com/xtermjs/xterm.js/issues/675</a></p>\n<p>求问有什么办法</p>\n</div>","title":"xterm.js 安卓中文输入法，退格键会重复输入","last_reply_at":"2019-02-22T04:49:04.678Z","good":false,"top":false,"reply_count":0,"visit_count":151,"create_at":"2019-02-22T04:48:14.922Z","author":{"loginname":"hello00700","avatar_url":"https://avatars3.githubusercontent.com/u/47766245?v=4&s=120"}},{"id":"5671441a1d2912ce2a35aaa1","author_id":"530ed7b25adfcd9c0f0713b6","tab":"share","content":"<div class=\"markdown-text\"><p>也不知道是什么原因，刚开始不久的职业生涯，在技术这条路走着走着，和「登录」总是有着一个不解之缘。还记得当初学习Web编程的时候么？不管是Java、.Net、PHP，继经典「Hello World」之后，要写的很有可能就是「登录」功能。至今「登录」的问题还是让我心中一万只草泥马奔过。\n下面，给分享一下各种「登录」相关的需求</p>\n<h2>普通的登录</h2>\n<p>这个是极其普通的登录需求，要的就是一个登录页面，输入账号密码，提交Form表单，后端查询数据库对应用户名的密码，匹配正确则把用户记录到Session，不正确则返回错误。\n这种登录，在上学的时候，也许敬爱的老师就已经教过你了。\n但可能他没有教你的是，密码需要hash加密，session为什么可以记录登录用户的原理。</p>\n<p><strong>密码Hash</strong>\n密码hash，就是存进数据库的密码是一串密文，密文是明文密码通过不可逆算法得出的。在Nodejs中，你可以使用<a href=\"https://www.npmjs.com/package/bcryptjs\">bcryptjs</a>，它提供了<code>hash</code>以及对应的<code>compare</code>方法，非常适合用于密码的加密和对比。</p>\n<p><strong>Session原理</strong>\nSession的原理其实还是依赖了Cookie，所以Cookie才是记录用户凭证的真理。它的原理大概是酱紫的：服务器端维护一个session的表，这个表的每一条记录存的就是与某一个客户端的会话，会话会有过期时间，过期的会话会被清理。然后这个会话，会有一个对应的id，一般是一串长长的看不懂的字符串，然后这个字符串会被存储在客户端的cookie中，每一次请求服务器端都会带上这个cookie，服务器端就知道访问的就是哪个客户端了。\n欲知更多有关「Session原理」请点击传送门：<a href=\"http://www.jianshu.com/p/2b7c10291aad\">Session原理</a></p>\n<h2>使用独立登录系统</h2>\n<p>应项目需要，登录逻辑需要独立出来做成一个系统，就是另外一个项目。与原来的主站不是在同一个项目中了。一个域名是 <code>www.site.com</code>，一个则是<code>passport.site.com</code>了。要在不同的域名下进行登录，一般的方法是<code>www.site.com/login</code> 跳转到 <code>passport.site.com/login</code>，passport这边是一个登录页面，用户输入账号密码登录成功之后，passport会通过带着一个可逆加密的包含用户信息的token，重定向到<code>www.site.com</code>提供的回调处理地址，然后进行解密，匹配正确，则登录用户。\n要注意的是，这里的加密的信息需要包含一个时间戳，接收方需要认证这个时间戳，过期登录失败。避免token被窃取，被无限登录site系统。</p>\n<h2>单点登录</h2>\n<p>单点登录需要实现的需求，说白了就是在站点A的登录了，那么用户就自动在站点B、站点C、站点E、F、G登录。\n这又分两种情况，A站点和B站点是否在同一个二级域名下。\n假如是在同一个域名下，例如<code>siteA.site.com</code>与<code>siteB.site.com</code>，因为cookie允许设置到二级域名下<code>.site.com</code>，所以siteA和siteB是可以共享cookie的，用户的信息可以通过可逆加密放在二级域名下的cookie，并且设置<code>http only</code>，就可以一站登录，站站登录。\n而如果A站点和B站点不在同一二级域名下，例如<code>www.siteA.com</code>与<code>www.siteB.com</code>，他们就无法通过共享cookie的方式共享用户信息，所以需要用到jsonp的方式，用户在siteA登录之后，提供一个jsonp接口获取加密的用户信息，siteB访问这个jsonp获取加密信息。达到共享用户状态的效果。\n欲知更多有关「单点登录」请点击传送门：<a href=\"http://www.jianshu.com/p/613e44d4a464\">单点登录的三种实现方式</a></p>\n<h2>OAuth2.0登录</h2>\n<p>这就比较普遍了，现在随随便便做个网站，都接入「微信登录」、「微博登录」、「豆瓣登录」、「QQ登录」、「Github登录」、<em>@^</em>&amp;@%#^%^@%&amp;%@&amp;#…\n这些统一叫做：「第三方登录」。\n第三方登录都是实现了OAuth2.0协议的，流程大概是酱紫的：\n第三方提供一个登录入口，也就是第三方域名下的登录页面。主站需要登录的时候，引导用户重定向到第三方的登录页面，用户输入账号密码之后，登录第三方系统，第三方系统匹配帐号成功之后，带上一个code到主站的回调地址，主站接收到code，短时间内拿着code请求第三方提供获取长期凭证的接口(因为code有一个比较短的过期时间)，这个长期凭证叫<code>access_token</code>，获取之后就把这个<code>access_token</code>存到数据库中，请求一些第三方提供的API，需要用到这个<code>access_token</code>，因为这个token就是记录用户在第三方系统的一个身份凭证。\n一些系统，在获取<code>access_token</code>的时候，还会返回一个副参数<code>refresh_token</code>，因为<code>access_token</code>是有过期时间的，一旦过期了，主站可以使用<code>refresh_token</code>请求第三方提供的接口获取新的<code>access_token</code>以及新的<code>refresh_token</code>。\n在Nodejs中，你可以使用<code>passport</code>来给第三方登录提供一个统一解决方案，而如果你是开发「微信公众号」授权，除了<a href=\"https://www.npmjs.com/package/passport\">passport</a>，也可以使用<a href=\"https://www.npmjs.com/package/wechat-oauth\">wechat-oauth</a></p>\n<h2>在最后</h2>\n<p>其实登录问题，理解了Session原理是很重要的，这个也不难理解。然后站点之间的用户信息交流，就是通过各种跨域限制，各种加密解密而已。在做这个的时候，需要充分考虑到加密的token是否会被窃取的可能性，还要考虑让这个token加上时间的验证，在一些可能会被窃取，安全需求比较高的情况，就需要把token的时间设置的更短。还有就是加密的方式需要依照需求不同而选择可逆或者不可逆，hash sha1还是JWT(Json Web Token)。\nsha1加密，可以使用Nodejs自带的<code>crypto</code>，JWT可以使用<a href>jsonwebtoken</a></p>\n<hr>\n<p>如果本文对您有用\n请不要吝啬你们的Follow与Start\n这会大大支持我们继续创作</p>\n<p><strong>「Github」</strong>\nMZMonster ：<a href=\"https://github.com/MZMonster/\">@MZMonster</a>\nJC_Huang ：<a href=\"https://github.com/JerryC8080\">@JerryC8080</a></p>\n<p><strong>「简书」</strong>\nMZMonster：<a href=\"http://www.jianshu.com/collection/2a4335808d4c\">@MZMonster</a>\nJC_Huang：<a href=\"http://www.jianshu.com/users/843d2366f95b/latest_articles\">@JC_Huang</a></p>\n</div>","title":"登录那些事儿","last_reply_at":"2019-02-22T03:48:45.670Z","good":true,"top":false,"reply_count":42,"visit_count":28267,"create_at":"2015-12-16T10:59:38.333Z","author":{"loginname":"JerryC8080","avatar_url":"https://avatars0.githubusercontent.com/u/6801672?v=4&s=120"}},{"id":"5b972808ce9d14c2254df8b0","author_id":"56ea011fa70420bd420d0001","tab":"share","content":"<div class=\"markdown-text\"><p>楼主自己也是才踩 react 的路。。之前偷懒用了 vuejs 就不思上进了…无赖美帝都是 react 占据了90个点的江山.*\n**一直觉得学习，选择好的学习资料和学习的顺序很重要… 对了，路子顺…挫折感小. ** 希望自己的学习顺序，能给别人带来帮助.\n群主弄了个 QQ 技术交流群: 371932256 ，方便讨论我的 cnodejs 的 react 版本的项目…一起进步…也欢迎高手加入…哈哈…</p>\n<ol>\n<li>\n<p>掌握 react 的基本概念\n1.1 看视频课程：<a href=\"https://time.geekbang.org/course/intro/100\">https://time.geekbang.org/course/intro/100</a> （非推广…只是个人是个很热心的妹砸） 01 ~10\n1.2 边看然后边刷官方的 Main Concepts 部分的文档https://reactjs.org/docs/hello-world.html 做好第一步和第二步后，对 react 有基本的概念了…</p>\n</li>\n<li>\n<p>学习 redux/react-redux\n2.1 看ruanyifeng 的 redux/react-redux 教程… 看教程第一二篇的时候，会有个基本的概念呢…\n2.2  然后返回去看 11~ 15， 视频讲解的 redux、react 课程\n当然你在刷课课程中，也会不时的去看看官方文档看看些细节. flux 等概念\n2.3  在上述步骤（3.1 ~3.2 ） 中，你会做 Counter 的例子，了解 redux 的基本玩法… 也会把 Counter的例子改成结合 react-redux 类型的;\n如果这两个例子完成了…可以试试这个视频教程…\n2.4 完成一个小demo: <a href=\"https://www.youtube.com/watch?v=93p3LxR9xfM&amp;t=1168s\">https://www.youtube.com/watch?v=93p3LxR9xfM&amp;t=1168s</a> 这部分想必，对新手会绕一段时间…特别是 redux 这部分如果你没进去看过源码…有时候会被 API 绕晕…觉得 API 多\n这边是楼主写的 redux 阅读笔记: <a href=\"https://github.com/pandoracat/learn-react/blob/master/Notes/Redux/includes/markdown/ReduxSourceCode.md\">https://github.com/pandoracat/learn-react/blob/master/Notes/Redux/includes/markdown/ReduxSourceCode.md</a></p>\n</li>\n<li>\n<p>完成学习 react基本概念… redux/react-redux 基本用法后…（一定要试着敲每个课程的代码哟，扎扎实实走过来的，你内心才踏实)\n可以直接去 react-router 官网看看 demo, 边用用demo, 了解文档，了解用法. 如果有朋友觉得英文文档看起来吃力，可以看看这个 <a href=\"https://www.jianshu.com/p/1781bc1dd938#24-history\">https://www.jianshu.com/p/1781bc1dd938#24-history</a></p>\n</li>\n<li>\n<p>学习完这些后，咱看看 react 项目，代码咋拆分…咋组织\n课程22~25 ： <a href=\"https://time.geekbang.org/course/detail/100-11278\">https://time.geekbang.org/course/detail/100-11278</a></p>\n</li>\n<li>\n<p>这些都过了,下面看 react 怎么测试。关于 react 测试： 强行硬广一波自己的笔记：<a href=\"https://github.com/pandoracat/frontend-testing\">https://github.com/pandoracat/frontend-testing</a> ，我记录了自己的 javascript 测试的学习路程…</p>\n</li>\n<li>\n<p>上面这些你都做了…咱们再把视频教程撸撸… 再次提升下自己的理解…</p>\n</li>\n<li>\n<p>最后，react cnode , 新手练手都用它 😎…看看 它的 api, 咱们 ready go 写个项目试试.\n这边是我正在写的 <a href=\"https://github.com/pandoracat/react-cnode\">https://github.com/pandoracat/react-cnode</a> 欢迎瞧瞧…我会写自己的 readme, 方便你照着模仿一个…\n弱弱的觉得自己设计的风格还不错（偷笑,我是一个审美超级弱的前端妹纸）\n怎么开始这个用 <a href=\"http://cnodejs.org\">cnodejs.org</a> 做 api 服务器的练手项目呢?请点击：<a href=\"https://github.com/pandoracat/react-cnode\">https://github.com/pandoracat/react-cnode</a></p>\n</li>\n</ol>\n<p>群主弄了个 QQ 技术交流群: 371932256 ，方便讨论我的 cnodejs 的 react 版本的项目…一起进步…也欢迎高手加入…哈哈…</p>\n</div>","title":"分享自己的 react 学习路径","last_reply_at":"2019-02-22T03:43:43.337Z","good":false,"top":false,"reply_count":29,"visit_count":3395,"create_at":"2018-09-11T02:27:20.076Z","author":{"loginname":"alicePan","avatar_url":"https://avatars2.githubusercontent.com/u/9105986?v=4&s=120"}},{"id":"5c2edce13898674067a7b103","author_id":"5372465f3c72496d41009adc","tab":"share","content":"<div class=\"markdown-text\"><p>截止1 月 12日晚 22:00，有效参与人数共 252 人，抽取 5 名中奖者。\n恭喜以下中奖者🎉🎉🎉🎉🎉 gofromzero,MoeXian,yxcs,caoxiaoshuai1,langjy🎉🎉🎉🎉🎉\n请评论区留下联系方式。\n<img src=\"//static.cnodejs.org/Fvx9s9EjQk7IwNrAMO5_y7zJfrej\" alt=\"image.png\"></p>\n<p>---------------- 以下是原文 ----------------</p>\n<p>新书《Node.js开发实战》热卖，大获好评，感谢大家的支持，送几本书回馈给大家。</p>\n<p>赠书办法：</p>\n<ul>\n<li>只须在本贴留言即可。</li>\n<li>从回贴评论者中随机抽取中奖者，共计 5 本，每位中奖者 1 本。</li>\n<li>获赠名单公布在本帖，并在本贴下评论 @ 每位获赠的同学。</li>\n<li>截止时间 2019 年 1 月 12 日 22:00:00 （ UTC+8 ），以评论时间为准。</li>\n<li>由于本站不支持私信，请获奖同学在本帖回复联系方式，邮箱或者任何其它能联系到你的形式。</li>\n<li>开奖后 72 小时未能回复联系方式者视为放弃。</li>\n</ul>\n<p>试读样章：<a href=\"https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg\">https://pan.baidu.com/s/1x3c35AmJV4rcEj_W3A1WGg</a>\n京东有售：<a href=\"https://item.jd.com/12460185.html\">https://item.jd.com/12460185.html</a>\n<img src=\"//static.cnodejs.org/Finp2H7di-Equ_yMWsjJY6hxYGkh\" alt=\"WechatIMG148 copy.jpg\"></p>\n</div>","title":"送几本《Node.js开发实战》","last_reply_at":"2019-02-22T02:10:53.827Z","good":false,"top":false,"reply_count":356,"visit_count":9846,"create_at":"2019-01-04T04:11:13.570Z","author":{"loginname":"meikidd","avatar_url":"https://avatars0.githubusercontent.com/u/376338?v=4&s=120"}},{"id":"5bb0bf6f37a6965f59051df3","author_id":"5ba61ea38f5b0c1c59ea10b6","tab":"share","content":"<div class=\"markdown-text\"><h2>在线体验地址:<a href=\"http://vip.52tech.tech/\">http://vip.52tech.tech/</a></h2>\n<h2>GIthub源码：<a href=\"https://github.com/xiugangzhang/vip.github.io\">https://github.com/xiugangzhang/vip.github.io</a></h2>\n<h2>项目预览</h2>\n<p><img src=\"//static.cnodejs.org/FmjZMm4b3MUqJIuSB5aYS2PEW0pf\" alt=\"preview.jpg\"></p>\n<ul>\n<li>主页面\n<img src=\"//static.cnodejs.org/FhTjrj9HgY37ojGYNdLWupmBfSyv\" alt=\"preview.jpg\"></li>\n<li>登录页面\n<img src=\"//static.cnodejs.org/FrZr5Mck4VQD9ndVXhJGqA9XwHsU\" alt=\"login.jpg\"></li>\n<li>注册页面\n<img src=\"//static.cnodejs.org/FnXwM1CtMBcA7cFv66vlYb-t559E\" alt=\"register.jpg\"></li>\n<li>会员中心\n<img src=\"//static.cnodejs.org/FtCfCUeeIA8Y0WnYkhvzqlweqPbs\" alt=\"user.jpg\"></li>\n<li>电影播放页面\n<img src=\"//static.cnodejs.org/FryrTyzEeEFuOgD1uXrkwF4MzXn-\" alt=\"play.jpg\"></li>\n<li>电影弹幕功能\n<img src=\"//static.cnodejs.org/FhcOXAvbMZuafMrJzU00fMvRXot9\" alt=\"danmu.jpg\"></li>\n</ul>\n<h2>视频网站项目已经完功能如下：</h2>\n<h3>v1.0.3（当前最新版本）</h3>\n<ul>\n<li>\n<ol>\n<li>增加自动抓取功能，网站数据定期实时更新</li>\n</ol>\n<ul>\n<li>电影和电视剧数据抓取</li>\n<li>电影数据信息前端展现</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影页面图片的自动抓取、下载和展示</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>代码结构调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.2</h3>\n<ul>\n<li>\n<ol>\n<li>简化程序安装流程，新增可视化安装界面</li>\n</ol>\n<ul>\n<li>用户可直接输入数据库名、数据库地址、数据库用户名、数据库密码信息一键完成程序的安装</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>页面部分结构的调整</li>\n</ol>\n</li>\n</ul>\n<h3>v1.0.1</h3>\n<ul>\n<li>\n<ol>\n<li>用户中心的管理</li>\n</ol>\n<ul>\n<li>对于已经注册的用户，实现用户基本信息的修改</li>\n<li>用户密码的修改</li>\n<li>用户评论记录的查看</li>\n<li>用户收藏电影的查看和播放</li>\n<li>用户登录日志的查看</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影搜索功能（特色功能）</li>\n</ol>\n<ul>\n<li>实现了根据视频播放地址和视频名称全网视频的搜索和播放功能</li>\n<li>实现了正在热映，即将上映和TOP250的电影列表的展示</li>\n<li>电影收藏和取消功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>弹幕功能（特色功能）</li>\n</ol>\n<ul>\n<li>类似于B站等其他视频网站的弹幕功能，用户在登录之后可以实现在线发言</li>\n</ul>\n</li>\n</ul>\n<h3>v1.0.0</h3>\n<ul>\n<li>\n<ol>\n<li>用户主页的搭建：</li>\n</ol>\n<ul>\n<li>实现了主页轮播图的显示和切换，用户可以从数据库中自由配置和切换轮播图的显示</li>\n<li>实现了主页电影列表的显示：从数据库文件读取电影和电视剧列表信息并在前台显示</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>用户登录和注册页面的搭建：</li>\n</ol>\n<ul>\n<li>实现了用户的登录和注册功能</li>\n<li>用户注册和登录验证码提示功能</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>电影播放页面的搭建</li>\n</ol>\n<ul>\n<li>对于其他页面的任意可以展现电影列表的页面，用户可以直接点击列表，直接进入播放页面</li>\n<li>播放页面电影详细信息的展现</li>\n<li>对于加载速度较慢的视频，用户可以自由切换播放接口进行加速</li>\n<li>用户可以在相应的播放页面查看其他用户已经发表的评论，同时也可以在登录之后自由发表评论</li>\n</ul>\n</li>\n</ul>\n<h3>其他</h3>\n<ul>\n<li>\n<ol>\n<li>页面整体的风格模仿了Discuz等论坛网站的布局</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>网站首页的轮播图效果模仿了优酷、爱奇艺、腾讯视频等主流视频网站的轮播图效果，并且对该部分的效果实现进行了代码封装</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影底部的的友情链接，使用了大部分网站的分栏布局，用户可以添加自己的QQ群以及微信公众号方便增加自己网站的人气</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>主要列表的分页功能，对于一些内容显示较多的不能再一页显示完整的页面，使用了ajax无刷新分页对数据进行多条展示，提高了用户的体验</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>目前主流浏览器中也做了相应测试，建议大家使用谷歌或者火狐浏览器，效果可能会更好</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>未使用其他第三方框架，首页和播放页均为纯原生的HTML，CSS， js实现（至于这个xframe-min-1.0.js文件可以参见我的GitHub xframe.js这个开源项目）</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>电影播放页面：此处也是类似于当前主流网站的的播放页面，左侧为播放窗口，右侧部分为电影的详细信息</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>底部导航：使用分栏的方式实现了底部的导航，前面的为友情链接，后面的一个为网站的微信，Q微博等联系方式</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>用户中心：这部分实现了修改密码，评论，登录，日志管理，收藏电影的功能，用户可以自由切换</li>\n</ol>\n</li>\n</ul>\n<h2>程序目录结构说明</h2>\n<pre class=\"prettyprint\"><code>vip.github.io:\n├─controllers               &#x2F;&#x2F; 控制层\n├─data                      &#x2F;&#x2F; 数据抓取层\n├─logs                      &#x2F;&#x2F; 后台日志\n│  ├─errlog                 &#x2F;&#x2F; 错误日志\n│  ├─othlog                 &#x2F;&#x2F; 其他日志\n│  └─reqlog                 &#x2F;&#x2F; 请求日志\n├─models                    &#x2F;&#x2F; 模型层\n├─static                    &#x2F;&#x2F; 静态页\n│  ├─css                    &#x2F;&#x2F; 样式表\n│  ├─images                 &#x2F;&#x2F; 静态图片资源\n│  └─js                     &#x2F;&#x2F; js脚本\n├─utils                     &#x2F;&#x2F; 工具相关\n├─views                     &#x2F;&#x2F; 视图层\n└─www                       &#x2F;&#x2F; 静态资源\n    ├─css                   &#x2F;&#x2F; 样式表\n    ├─html                  &#x2F;&#x2F; html文件\n    ├─images                &#x2F;&#x2F; 静态图片资源\n    ├─js                    &#x2F;&#x2F; js脚本\n    │  └─movielist          &#x2F;&#x2F; 搜索页电影列表\n    │      ├─components     &#x2F;&#x2F; top250&#x2F;即将上映\n    │      └─in_theaters    &#x2F;&#x2F; 正在热映\n    └─uploads               &#x2F;&#x2F; 文件上传目录\n        ├─avatar            &#x2F;&#x2F; 用户图像\n        └─movie             &#x2F;&#x2F; 电影图标\n\n</code></pre><h2>程序安装方法</h2>\n<ul>\n<li>\n<ol>\n<li>确保电脑已经安装了NodeJS环境，运行版本尽量保持最新（V8以上吧），选择本地的一个路径，然后运行命令：</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   git clone https:&#x2F;&#x2F;github.com&#x2F;xiugangzhang&#x2F;vip.github.io.git\n</code></pre><ul>\n<li>\n<ol>\n<li>进入程序的主目录（包含app.js的那个文件夹）运行命令：npm install，系统就会自动安装该程序的依赖包；</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>在以上的步骤都执行完成且正确的情况下，就可以在程序主目录下面（有app.js的那个目录）,运行命令</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>   node app.js\n</code></pre><p>之后就会自动在浏览器中打开本程序安装的主界面；</p>\n<ul>\n<li>\n<ol>\n<li>如果是windows环境下，本程序提供了可视化的安装。用户可在程序的安装界面输入数据库名、数据库主机地址、数据库用户名、数据库密码，之后点击按钮立即安装即可，在输入的参数全部正确的情况下，就会后台自动安装程序，安装成功之后会自动跳转到网站首页；\n<img src=\"//static.cnodejs.org/FqNdjsfo5whahU-WvEC8WOpBBXA5\" alt=\"installing.jpg\"></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>如果是Linux环境下，请提前准备好数据库名（database=video）、数据库主机地址（host=localhost）、数据库用户名（user=root）、数据库密码（password=123456 ），按照如下格式保存为config.properties文件，请确保这里的配置信息和你的数据库配置信息完全一致；</li>\n</ol>\n</li>\n</ul>\n<pre class=\"prettyprint\"><code>    database=video               \n    host=localhost          \n    user=root               \n    password=123456         \n</code></pre><ul>\n<li>\n<ol>\n<li>在线演示站点：<a href=\"http://vip.52tech.tech\">http://vip.52tech.tech</a></li>\n</ol>\n</li>\n<li>\n<ol>\n<li>对于安装和使用的过程中如果有什么问题和建议，也欢迎交流和提出建议，可以在issue去发起话题讨论，或直接联系邮箱：tech52admin@126.com</li>\n</ol>\n</li>\n</ul>\n</div>","title":"【VIP视频网站项目】基于Nodejs开发的VIP视频网站项目及源码分享【v1.0.3版】","last_reply_at":"2019-02-21T13:35:49.866Z","good":false,"top":false,"reply_count":18,"visit_count":13366,"create_at":"2018-09-30T12:19:59.585Z","author":{"loginname":"xiugangzhang","avatar_url":"https://avatars3.githubusercontent.com/u/29092258?v=4&s=120"}},{"id":"5203a71844e76d216a727d2e","author_id":"5167d7b96d38277306098b54","tab":"share","content":"<div class=\"markdown-text\"><p>所谓工欲善其事，必先利其器，所以通读了<a href=\"https://npmjs.org/package/cheerio\">cheerio</a>的API，顺便翻译了一遍，有些地方因为知道的比较少，不知道什么意思，保留了英文，希望各位不吝告诉我，然后一起把这个翻译完成。</p>\n<p>###cheerio\n为服务器特别定制的，快速、灵活、实施的jQuery核心实现.\n###Introduction\n将HTML告诉你的服务器</p>\n<pre class=\"prettyprint\"><code>var cheerio = require(&#x27;cheerio&#x27;),\n    $ = cheerio.load(&#x27;&lt;h2 class=&quot;title&quot;&gt;Hello world&lt;&#x2F;h2&gt;&#x27;);\n\n$(&#x27;h2.title&#x27;).text(&#x27;Hello there!&#x27;);\n$(&#x27;h2&#x27;).addClass(&#x27;welcome&#x27;);\n\n$.html();\n&#x2F;&#x2F;=&gt; &lt;h2 class=&quot;title welcome&quot;&gt;Hello there!&lt;&#x2F;h2&gt;\n</code></pre><p>###Installation\nnpm install cheerio</p>\n<p>###Features\n**❤ 相似的语法:**Cheerio 包括了 jQuery 核心的子集。Cheerio  从jQuery库中去除了所有 DOM不一致性和浏览器尴尬的部分，揭示了它真正优雅的API。</p>\n<p>**ϟ 闪电般的块:**Cheerio 工作在一个非常简单，一致的DOM模型之上。解析，操作，呈送都变得难以置信的高效。基础的端到端的基准测试显示Cheerio 大约比JSDOM快八倍(8x)。</p>\n<p><strong>❁ 巨灵活:</strong> Cheerio 封装了兼容的htmlparser。Cheerio 几乎能够解析任何的 HTML 和 XML document。</p>\n<p>###What about JSDOM\n我写cheerio 是因为我发现我自己对JSDOM越来越沮丧。对于我来说，总是会一次又一次的碰上几个难点。</p>\n<ul>\n<li>\n<p><strong>JSDOM内建的解析太过于严格</strong>: JSDOM附带的HTML解析不能处理很多当下的大众的网站。</p>\n</li>\n<li>\n<p><strong>JSDOM太慢</strong>:用JSDOM解析大型网站存在可见的延迟。</p>\n</li>\n<li>\n<p><strong>JSDOM太累赘</strong>:JSDOM的目标是提供一个我们在浏览器里面看到的相同的 DOM 环境。我从没有真的需要所有这些东西，我只是想要一个简单的，相似的方法去处理HTML。</p>\n</li>\n</ul>\n<p>###When I would use JSDOM\nCheerio 不会解决你的所有问题。我人会使用JSDOM如果我需要用一个在服务器上的浏览器环境，特别是如果我想要自动化一些功能测试。\n###API\n####我们将用到的标记示例\n&lt;ul id=“fruits”&gt;\n&lt;li class=“apple”&gt;Apple&lt;/li&gt;\n&lt;li class=“orange”&gt;Orange&lt;/li&gt;\n&lt;li class=“pear”&gt;Pear&lt;/li&gt;\n&lt;/ul&gt;</p>\n<p>这是我们将会在所有的API例子中用到的HTML标记</p>\n<p>####Loading\n首先你需要加载HTML。这一步对jQuery来说是必须的，since jQuery operates on the one, baked-in DOM。通过Cheerio,我们需要把HTML document 传进去。</p>\n<p>这是<strong>首选</strong>:</p>\n<pre class=\"prettyprint\"><code>var cheerio = require(&#x27;cheerio&#x27;),\n    $ = cheerio.load(&#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;);\n</code></pre><p>或者通过传递字符串作为内容来加载HTML:</p>\n<pre class=\"prettyprint\"><code>$ = require(&#x27;cheerio&#x27;);\n$(&#x27;ul&#x27;, &#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;);\n</code></pre><p>Or as the root:</p>\n<pre class=\"prettyprint\"><code>$ = require(&#x27;cheerio&#x27;);\n$(&#x27;li&#x27;, &#x27;ul&#x27;, &#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;);\n</code></pre><p>你也可以传递一个额外的对象给.load()如果你需要更改任何的默认解析选项的话:</p>\n<pre class=\"prettyprint\"><code>$ = cheerio.load(&#x27;&lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&#x27;, {\n    ignoreWhitespace: true,\n    xmlMode: true\n});\n</code></pre><p>这些解析选项都是直接来自htmlparser ，因此任何在htmlparser里有效的选项在Chreeio里也是行得通的。默认的选项如下:</p>\n<pre class=\"prettyprint\"><code>{\n    ignoreWhitespace: false,\n    xmlMode: false,\n    lowerCaseTags: false\n}\n</code></pre><p>想看选项清单和它们都效果，看\n<a href=\"https://github.com/fb55/DomHandler\">这个</a>和\n<a href=\"https://github.com/fb55/htmlparser2/wiki/Parser-options\">这个</a></p>\n<p>####Selectors</p>\n<p>Cheerio的选择器用起来几乎和jQuery一样，所以API也很相似。</p>\n<p><strong>$(selectior,[context],[root])</strong></p>\n<p>选择器在 Context 范围内搜索，Context又在Root范围内搜索。selector 和context可是是一个字符串表达式，DOM元素，和DOM元素的数组，或者chreeio对象。root 是通常是HTML 文档字符串。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;, &#x27;#fruits&#x27;).text()\n&#x2F;&#x2F;=&gt; Apple\n\n$(&#x27;ul .pear&#x27;).attr(&#x27;class&#x27;)\n&#x2F;&#x2F;=&gt; pear\n\n$(&#x27;li[class=orange]&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n</code></pre><p>####Attributes\n获得和修改属性</p>\n<p><strong>.attr(name,value)</strong></p>\n<p>获得和修改属性。在匹配的元素中只能获得第一元素的属性。如果设置一个属性的值为null，则移除这个属性。你也可以传递一对键值，或者一个函数。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).attr(&#x27;id&#x27;)\n&#x2F;&#x2F;=&gt; fruits\n\n$(&#x27;.apple&#x27;).attr(&#x27;id&#x27;, &#x27;favorite&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;apple&quot; id=&quot;favorite&quot;&gt;Apple&lt;&#x2F;li&gt;\n</code></pre><p>更多信息请看<a href=\"http://api.jquery.com/attr/\">这里</a></p>\n<p><strong>value([value])</strong></p>\n<p>获得和修改input,select,textarea的value.注意: 对于传递键值和函数的支持还没有被加进去。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;input[type=&quot;text&quot;]&#x27;).val()\n=&gt; input_text\n\n$(&#x27;input[type=&quot;text&quot;]&#x27;).val(&#x27;test&#x27;).html()\n=&gt; &lt;input type=&quot;text&quot; value=&quot;test&quot;&#x2F;&gt;\n</code></pre><p><strong>.removeAttr(name)</strong></p>\n<p>通过name删除属性</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).removeAttr(&#x27;class&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li&gt;Pear&lt;&#x2F;li&gt;\n</code></pre><p><strong>.hasClass( className )</strong></p>\n<p>检查匹配的元素是否有给出的类名</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).hasClass(&#x27;pear&#x27;)\n&#x2F;&#x2F;=&gt; true\n\n$(&#x27;apple&#x27;).hasClass(&#x27;fruit&#x27;)\n&#x2F;&#x2F;=&gt; false\n\n$(&#x27;li&#x27;).hasClass(&#x27;pear&#x27;)\n&#x2F;&#x2F;=&gt; true\n</code></pre><p><strong>.addClass(className)</strong></p>\n<p>增加class(es)给所有匹配的elements.也可以传函数。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).addClass(&#x27;fruit&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;pear fruit&quot;&gt;Pear&lt;&#x2F;li&gt;\n\n$(&#x27;.apple&#x27;).addClass(&#x27;fruit red&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;apple fruit red&quot;&gt;Apple&lt;&#x2F;li&gt;\n</code></pre><p>更多信息看<a href=\"http://api.jquery.com/addClass/\">这里</a></p>\n<p><strong>.removeClass([className])</strong></p>\n<p>从选择的elements里去除一个或多个有空格分开的class。如果className 没有定义，所有的classes将会被去除，也可以传函数。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).removeClass(&#x27;pear&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;&quot;&gt;Pear&lt;&#x2F;li&gt;\n\n$(&#x27;.apple&#x27;).addClass(&#x27;red&#x27;).removeClass().html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;&quot;&gt;Apple&lt;&#x2F;li&gt;\n</code></pre><p>更多信息看<a href=\"http://api.jquery.com/removeClass/\">这里</a></p>\n<p><strong>.is.(selector)</strong></p>\n<p><strong>.is(function(index))</strong></p>\n<p>有任何元素匹配selector就返回true。如果使用判定函数，判定函数在选中的元素中执行，所以this指向当前的元素。</p>\n<p>####Traversing</p>\n<p><strong>.find(selector)</strong></p>\n<p>获得一个在匹配的元素中由选择器滤过的后代。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).find(&#x27;li&#x27;).length\n&#x2F;&#x2F;=&gt; 3\n</code></pre><p><strong>.parent([selector])</strong></p>\n<p>获得每个匹配元素的parent,可选择性的通过selector筛选。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).parent().attr(&#x27;id&#x27;)\n&#x2F;&#x2F;=&gt; fruits\n</code></pre><p><strong>.parents([selector])</strong></p>\n<p>获得通过选择器筛选匹配的元素的parent集合。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).parents().length\n&#x2F;&#x2F; =&gt; 2\n$(&#x27;.orange&#x27;).parents(&#x27;#fruits&#x27;).length\n&#x2F;&#x2F; =&gt; 1\n</code></pre><p><strong>.closest([selector])</strong></p>\n<p>对于每个集合内的元素，通过测试这个元素和DOM层级关系上的祖先元素，获得第一个匹配的元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).closest()\n&#x2F;&#x2F; =&gt; []\n$(&#x27;.orange&#x27;).closest(&#x27;.apple&#x27;)\n&#x2F;&#x2F; =&gt; []\n$(&#x27;.orange&#x27;).closest(&#x27;li&#x27;)\n&#x2F;&#x2F; =&gt; [&lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;]\n$(&#x27;.orange&#x27;).closest(&#x27;#fruits&#x27;)\n&#x2F;&#x2F; =&gt; [&lt;ul id=&quot;fruits&quot;&gt; ... &lt;&#x2F;ul&gt;]\n</code></pre><p><strong>.next()</strong>\n获得第一个本元素之后的同级元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).next().hasClass(&#x27;orange&#x27;)\n&#x2F;&#x2F;=&gt; true\n</code></pre><p><strong>.nextAll()</strong></p>\n<p>获得本元素之后的所有同级元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).nextAll()\n&#x2F;&#x2F;=&gt; [&lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;, &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;]\n</code></pre><p><strong>.prev()</strong></p>\n<p>获得本元素之前的第一个同级元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).prev().hasClass(&#x27;apple&#x27;)\n&#x2F;&#x2F;=&gt; true\n</code></pre><p><strong>.preAll()</strong></p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).prevAll()\n&#x2F;&#x2F;=&gt; [&lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;, &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;]\n</code></pre><p>获得本元素前的所有同级元素</p>\n<p><strong>.slice(start,[end])</strong></p>\n<p>获得选定范围内的元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).slice(1).eq(0).text()\n&#x2F;&#x2F;=&gt; &#x27;Orange&#x27;\n\n$(&#x27;li&#x27;).slice(1, 2).length\n&#x2F;&#x2F;=&gt; 1\n</code></pre><p><strong>.siblings(selector)</strong></p>\n<p>获得被选择的同级元素，除去自己??</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).siblings().length\n&#x2F;&#x2F;=&gt; 2\n\n$(&#x27;.pear&#x27;).siblings(&#x27;.orange&#x27;).length\n&#x2F;&#x2F;=&gt; 1\n</code></pre><p><strong>.children(selector)</strong></p>\n<p>获被选择元素的子元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).children().length\n&#x2F;&#x2F;=&gt; 3\n\n$(&#x27;#fruits&#x27;).children(&#x27;.pear&#x27;).text()\n&#x2F;&#x2F;=&gt; Pear\n</code></pre><p><strong>.each(function(index,element))</strong></p>\n<p>迭代一个cheerio对象，为每个匹配元素执行一个函数。When the callback is fired, the function is fired in the context of the DOM element, so this refers to the current element, which is equivalent to the function parameter element.要提早跳出循环，返回false.</p>\n<pre class=\"prettyprint\"><code>var fruits = [];\n\n$(&#x27;li&#x27;).each(function(i, elem) {\n  fruits[i] = $(this).text();\n});\n\nfruits.join(&#x27;, &#x27;);\n&#x2F;&#x2F;=&gt; Apple, Orange, Pear\n</code></pre><p><strong>.map(function(index,element))</strong></p>\n<p>迭代一个cheerio对象，为每个匹配元素执行一个函数。Map会返回一个迭代结果的数组。the function is fired in the context of the DOM element, so this refers to the current element, which is equivalent to the function parameter element</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).map(function(i, el) {\n  &#x2F;&#x2F; this === el\n  return $(this).attr(&#x27;class&#x27;);\n}).join(&#x27;, &#x27;);\n&#x2F;&#x2F;=&gt; apple, orange, pear\n</code></pre><p><strong>.filter(selector)</strong></p>\n<p><strong>.filter(function(index))</strong></p>\n<p>迭代一个cheerio对象，滤出匹配选择器或者是传进去的函数的元素。如果使用函数方法，这个函数在被选择的元素中执行，所以this指向的手势当前元素。</p>\n<p>Selector:</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).filter(&#x27;.orange&#x27;).attr(&#x27;class&#x27;);\n&#x2F;&#x2F;=&gt; orange\n</code></pre><p>Function:</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).filter(function(i, el) {\n  &#x2F;&#x2F; this === el\n  return $(this).attr(&#x27;class&#x27;) === &#x27;orange&#x27;;\n}).attr(&#x27;class&#x27;)\n&#x2F;&#x2F;=&gt; orange\n</code></pre><p><strong>.first()</strong></p>\n<p>会选择chreeio对象的第一个元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).children().first().text()\n&#x2F;&#x2F;=&gt; Apple\n</code></pre><p><strong>.last()</strong></p>\n<pre class=\"prettyprint\"><code>$(&#x27;#fruits&#x27;).children().last().text()\n&#x2F;&#x2F;=&gt; Pear\n</code></pre><p>会选择chreeio对象的最后一个元素</p>\n<p><strong>.eq(i)</strong></p>\n<p>通过索引筛选匹配的元素。使用.eq(-i)就从最后一个元素向前数。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).eq(0).text()\n&#x2F;&#x2F;=&gt; Apple\n\n$(&#x27;li&#x27;).eq(-1).text()\n&#x2F;&#x2F;=&gt; Pear\n</code></pre><p>###Manipulation</p>\n<p>改变DOM结构的方法</p>\n<p><strong>.append(content,[content…])</strong></p>\n<p>在每个元素最后插入一个子元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).append(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.prepend(content,[content,…])</strong></p>\n<p>在每个元素最前插入一个子元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).prepend(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.after(content,[content,…])</strong></p>\n<p>在每个匹配元素之后插入一个元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).after(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.before(content,[content,…])</strong></p>\n<p>在每个匹配的元素之前插入一个元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.apple&#x27;).before(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.remove( [selector] )</strong></p>\n<p>从DOM中去除匹配的元素和它们的子元素。选择器用来筛选要删除的元素。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.pear&#x27;).remove()\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.replaceWith( content )</strong></p>\n<p>替换匹配的的元素</p>\n<pre class=\"prettyprint\"><code>var plum = $(&#x27;&lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;&#x27;)\n$(&#x27;.pear&#x27;).replaceWith(plum)\n$.html()\n&#x2F;&#x2F;=&gt; &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;     &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;     &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;     &lt;li class=&quot;plum&quot;&gt;Plum&lt;&#x2F;li&gt;\n&#x2F;&#x2F;   &lt;&#x2F;ul&gt;\n</code></pre><p><strong>.empty()</strong></p>\n<p>清空一个元素，移除所有的子元素</p>\n<pre class=\"prettyprint\"><code>$(&#x27;ul&#x27;).empty()\n$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;&lt;&#x2F;ul&gt;\n</code></pre><p><strong>.html( [htmlString] )</strong></p>\n<p>获得元素的HTML字符串。如果htmlString有内容的话，将会替代原来的HTML</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).html()\n&#x2F;&#x2F;=&gt; Orange\n\n$(&#x27;#fruits&#x27;).html(&#x27;&lt;li class=&quot;mango&quot;&gt;Mango&lt;&#x2F;li&gt;&#x27;).html()\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;mango&quot;&gt;Mango&lt;&#x2F;li&gt;\n</code></pre><p><strong>.text( [textString] )</strong></p>\n<p>获得元素的text内容，包括子元素。如果textString被指定的话，每个元素的text内容都会被替换。</p>\n<pre class=\"prettyprint\"><code>$(&#x27;.orange&#x27;).text()\n&#x2F;&#x2F;=&gt; Orange\n\n$(&#x27;ul&#x27;).text()\n&#x2F;&#x2F;=&gt;  Apple\n&#x2F;&#x2F;    Orange\n&#x2F;&#x2F;    Pear\n</code></pre><p>###Rendering</p>\n<p>如果你想呈送document，你能使用html多效用函数。</p>\n<pre class=\"prettyprint\"><code>$.html()\n&#x2F;&#x2F;=&gt;  &lt;ul id=&quot;fruits&quot;&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;apple&quot;&gt;Apple&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;orange&quot;&gt;Orange&lt;&#x2F;li&gt;\n&#x2F;&#x2F;      &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n&#x2F;&#x2F;    &lt;&#x2F;ul&gt;\n</code></pre><p>如果你想呈送outerHTML,你可以使用 $.html(selector)</p>\n<pre class=\"prettyprint\"><code>$.html(&#x27;.pear&#x27;)\n&#x2F;&#x2F;=&gt; &lt;li class=&quot;pear&quot;&gt;Pear&lt;&#x2F;li&gt;\n</code></pre><p>默认的,html会让一些标签保持开标签的状态.有时候你想呈现一个有效的XML文档.例如下面这个:</p>\n<pre class=\"prettyprint\"><code>$ = cheerio.load(&#x27;&lt;media:thumbnail url=&quot;http:&#x2F;&#x2F;www.foo.com&#x2F;keyframe.jpg&quot; width=&quot;75&quot; height=&quot;50&quot; time=&quot;12:05:01.123&quot;&#x2F;&gt;&#x27;);\n</code></pre><p>然后为了呈现这个XML,你需要使用<code>xml</code>这个函数:</p>\n<pre class=\"prettyprint\"><code>$.xml()\n&#x2F;&#x2F;=&gt;  &lt;media:thumbnail url=&quot;http:&#x2F;&#x2F;www.foo.com&#x2F;keyframe.jpg&quot; width=&quot;75&quot; height=&quot;50&quot; time=&quot;12:05:01.123&quot;&#x2F;&gt;\n</code></pre><p>###Miscellaneous</p>\n<p>不属于其它地方的DOM 元素方法</p>\n<p><strong>.toArray()</strong></p>\n<p>取得所有的在DOM元素，转化为数组、</p>\n<pre class=\"prettyprint\"><code>$(&#x27;li&#x27;).toArray()\n&#x2F;&#x2F;=&gt; [ {...}, {...}, {...} ]\n</code></pre><p><strong>.clone()</strong></p>\n<p>克隆cheerio对象</p>\n<pre class=\"prettyprint\"><code>var moreFruit = $(&#x27;#fruits&#x27;).clone()\n</code></pre><p>###Utilities</p>\n<p><strong>$.root</strong>\n有时候你想找到最上层的root元素,那么<code>$.root()</code>就能获得:</p>\n<pre class=\"prettyprint\"><code>$.root().append(&#x27;&lt;ul id=&quot;vegetables&quot;&gt;&lt;&#x2F;ul&gt;&#x27;).html();\n&#x2F;&#x2F;=&gt; &lt;ul id=&quot;fruits&quot;&gt;...&lt;&#x2F;ul&gt;&lt;ul id=&quot;vegetables&quot;&gt;&lt;&#x2F;ul&gt;\n</code></pre><p><strong>$.contains( container, contained )</strong></p>\n<p>查看cotained元素是否是container元素的子元素</p>\n<p><strong>$.parseHTML( data [, context ] [, keepScripts ] )</strong></p>\n<p>将字符串解析为DOM节点数组。context参数对chreeio没有意义，但是用来维护APi的兼容性。</p>\n<p>###Screencasts</p>\n<p><a href=\"http://vimeo.com/31950192\">http://vimeo.com/31950192</a></p>\n<p>这个视频教程是follow-up Nettut的&quot;How to Scrape Web Pages with Node.js and jQuery&quot;，用 cheerio而不是JSDOM+JQuery. 这个视频就是展示chreeio多牛B，多快的。</p>\n</div>","title":"通读cheerio API","last_reply_at":"2019-02-21T11:44:43.737Z","good":true,"top":false,"reply_count":29,"visit_count":133113,"create_at":"2013-08-08T14:11:36.535Z","author":{"loginname":"ggaaooppeenngg","avatar_url":"https://avatars.githubusercontent.com/u/4769989?v=3&s=120"}},{"id":"5c54046c05cc322e7b136ea7","author_id":"57d216e13d3520a5387c2b53","tab":"ask","content":"<div class=\"markdown-text\"><p>我知道一般程序员做笔记都用markdown，但是支持markdown的笔记软件也有很多。</p>\n<p>我之前都是用txt。\n优点只有一个：方便</p>\n<p>缺点一堆</p>\n<p>求推荐一个用起来顺手的。最好能登陆更新那种的。</p>\n</div>","title":"大家好，问个问题，请问大家遇到做笔记的时候用什么软件啊","last_reply_at":"2019-02-21T11:15:44.145Z","good":false,"top":false,"reply_count":17,"visit_count":1113,"create_at":"2019-02-01T08:33:48.295Z","author":{"loginname":"a69694510","avatar_url":"https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"}},{"id":"5b164efa29e6e510415b2803","author_id":"5b164c1957137f22415c4958","tab":"ask","content":"<div class=\"markdown-text\"><p>首先，我是做移动端iOS，最近在学Node,目前再看Node in Action这本书，感觉自己有点像无头苍蝇。书中的很多例子都是构建web应用，而我的前端知识呢?还停留在小学水平，所有有点迷茫。</p>\n<p>能不能来个老司机来带带我，帮我看看怎么学习是最高效的.\n老司机们~</p>\n</div>","title":"移动端入门Node.js怎么学习?","last_reply_at":"2019-02-21T10:54:28.995Z","good":false,"top":false,"reply_count":61,"visit_count":5799,"create_at":"2018-06-05T08:51:06.562Z","author":{"loginname":"jincc","avatar_url":"https://avatars1.githubusercontent.com/u/12285323?v=4&s=120"}},{"id":"5c6e1d28e1a81129a7ad91a6","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 面试季手册。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000018227761\">javascript 面试的完美指南(开发者视角)</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>为了说明 JS 面试的复杂性，首先，请尝试给出以下结果：</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(2.0 == “2” == new Boolean(true) == “1”)\n</code></pre><p>十有八九的会给出false， 其实运行结果是true，原因请看 <a href=\"https://youtu.be/P8ltWIqDPzo\">这里</a>。</p>\n<h3>1) 理解 JS 函数</h3>\n<p>函数是 JavaScript 的精华，是 JS 一等公民。JS 函数不仅仅是一个普通的函数，与其他语言不同，JS 函数可以赋值给变量，作为参数传递给另一个函数，也可以从另一个函数返回。</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(square(5));\n&#x2F;* ... *&#x2F;\nfunction square(n) { return n * n; }\n</code></pre><p>以为代码很简单，大家应该都知道会打印：<code>25</code>。接着看一个：</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(square(5));\n \nvar square = function(n) { \n  return n * n; \n}\n</code></pre><p>乍一看，你可能会忍不住说也打印了 <code>25</code>。但很不幸，会报错：</p>\n<pre class=\"prettyprint language-javascript\"><code>TypeError: square is not a function\n</code></pre><p>在 JavaScript 中，如果将函数定义为变量，变量名将被提升，是 JS 执行到它的<strong>定义</strong>才能被访问。</p>\n<p>你可能在一些代码中频繁的见到如下代码。</p>\n<pre class=\"prettyprint language-javascript\"><code>var simpleLibrary = function() {\n   var simpleLibrary = {\n        a,\n        b,\n        add: function(a, b) {\n            return a + b;\n        },\n        subtract: function(a, b) {\n            return a - b;   \n        }\n   }\n  return simpleLibrary;\n}();\n</code></pre><p>为什么会做这种奇怪的事情？ 这是因为一个函数变量中变量和函数被分装，可以避免全局变量污染。 <strong>JQuery</strong> 到<strong>Lodash</strong> 的库采用这种技术提供 <code>$</code>、<code>_</code> 等</p>\n<h3>2) 理解 bind、apply 和 call</h3>\n<p>你可能在所有常用库中看到过这三个函数。它们允许局部套用， 我们可以把功能组合到不同的函数。一个优秀的js开发者可以随时告诉你关于这三个函数。</p>\n<p>基本上，这些是改变行为以实现某些功能的原型方法，根据 JS 开发人员 Chad 的说法，用法如下：</p>\n<p>希望使用某个上下文调用该函数，请使用 <code>.bind()</code> ，这在事件中很有用。 如果要立即调用函数，请使用<code>.call()</code> 或 <code>.apply()</code>，并修改上下文。</p>\n<h4><strong>举例说明</strong></h4>\n<p>让我们看看上面的陈述是什么意思! 假设你的数学老师要求你创建一个库并提交。你写了一个抽象的库，它可以求出圆的面积和周长：</p>\n<pre class=\"prettyprint language-javascript\"><code>var mathLib = {\n    pi: 3.14,\n    area: function(r) {\n        return this.pi * r * r;\n    },\n    circumference: function(r) {\n        return 2 * this.pi * r;\n    }\n};\n</code></pre><p>提交后，老师调用了它：</p>\n<pre class=\"prettyprint language-javacript\"><code>mathLib.area(2);\n12.56\n</code></pre><p>老师发现他给你要求是 <code>pi</code> 精确到小数点后 <code>5</code> 位数而你只精确到 <code>2</code> 位， 现在由于最后期限已过你没有机会提交库。 这里 JS的 <code>call</code> 函数可以帮你， 只需要调用你的代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>mathLib.area.call({pi: 3.1.159}, 2)\n</code></pre><p>它会动态地获取新的 <code>pi</code> 值,结果如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>12.56636\n</code></pre><p>这时，注意到 <code>call</code> 函数具有两个参数：</p>\n<ul>\n<li>Context</li>\n<li>函数参数</li>\n</ul>\n<p>在 <code>area</code> 函数中， 上下文是对象被关键词 <code>this</code> 代替，后面的参数作为函数参数被传递。 如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var cylinder = {\n    pi: 3.14,\n    volume: function(r, h) {\n        return this.pi * r * r * h;\n    }\n};\n\n</code></pre><p>调用方式如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>cylinder.volume.call({pi: 3.14159}, 2, 6);\n75.39815999999999\n</code></pre><p><strong>Apply</strong> 类似，只是函数参数作为数组传递。</p>\n<pre class=\"prettyprint language-javascript\"><code>cylinder.volume.apply({pi: 3.14159}, [2, 6]);\n75.39815999999999\n</code></pre><p>如果你会使用 <strong>call</strong> 你基本就会用 <strong>apply</strong> 了，反之亦然， 那 <strong>bind</strong> 的用法又是如何呢 ？</p>\n<p><strong>bind</strong> 将一个全新的 <strong>this</strong> 注入到指定的函数上，改变 <strong>this</strong> 的指向， 使用 <strong>bind</strong> 时，函数不会像 <code>call</code> 或 <code>apply</code> 立即执行。</p>\n<pre class=\"prettyprint language-javascript\"><code>var newVolume = cylinder.volume.bind({pi: 3.14159});\nnewVolume(2,6); &#x2F;&#x2F; Now pi is 3.14159\n</code></pre><p><strong>bind</strong> 用途是什么?它允许我们将上下文注入一个函数，该函数返回一个具有更新上下文的新函数。这意味着这个变量将是用户提供的变量，这在处理 JavaScript 事件时非常有用。</p>\n<h3>3) 理解 js 作用域(闭包)</h3>\n<p>JavaScript 的作用域是一个潘多拉盒子。从这一个简单的概念中，就可以构造出数百个难回答的面试问题。有三种作用域：</p>\n<ul>\n<li>全局作用域</li>\n<li>本地/函数作用域</li>\n<li>块级作用域(ES6引进)</li>\n</ul>\n<p>全局作用域事例如下:</p>\n<pre class=\"prettyprint language-javascript\"><code>x = 10;\nfunction Foo() {\n  console.log(x); &#x2F;&#x2F; Prints 10\n}\nFoo()\n</code></pre><p>函数作用域生效当你定义一个局部变量时：</p>\n<pre class=\"prettyprint language-javascript\"><code>pi = 3.14;\nfunction circumference(radius) {    \n     pi = 3.14159;\n     console.log(2 * pi * radius); &#x2F;&#x2F; 打印 &quot;12.56636&quot; 不是 &quot;12.56&quot;\n}\ncircumference(2);\n</code></pre><p>ES16 标准引入了新的块作用域，它将变量的作用域限制为给定的括号块。</p>\n<pre class=\"prettyprint language-javascript\"><code>var a = 10;\n\nfunction Foo() {\n  if (true) {\n    let a = 4;\n  }\n\n  alert(a); &#x2F;&#x2F; alerts &#x27;10&#x27; because the &#x27;let&#x27; keyword\n}\nFoo();\n</code></pre><p>函数和条件都被视为块。以上例子应该弹出 <code>4</code>，因为 <code>if</code> 已执行。但 是ES6 销毁了块级变量的作用域，作用域进入全局。</p>\n<p>现在来到神奇的作用域，可以使用闭包来实现，JavaScript 闭包是一个返回另一个函数的函数。</p>\n<p>如果有人问你这个问题，编写一个输入一个字符串并逐次返回字符。 如果给出了新字符串，则应该替换旧字符串，类似简单的一个生成器。</p>\n<pre class=\"prettyprint language-javascript\"><code>function generator(input) {\n  var index = 0;\n  return {\n    next: function() {\n      if (index &lt; input.lenght) {\n        return input[index -1];\n      }\n      return &quot;&quot;;\n    }\n  }\n}\n</code></pre><p>执行如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var mygenerator = generator(&quot;boomerang&quot;);\nmygenerator.next(); &#x2F;&#x2F; returns &quot;b&quot;\nmygenerator.next() &#x2F;&#x2F; returns &quot;o&quot;\nmygenerator = generator(&quot;toon&quot;);\nmygenerator.next(); &#x2F;&#x2F; returns &quot;t&quot;\n</code></pre><p>在这里，作用域扮演着重要的角色。闭包是返回另一个函数并携带数据的函数。上面的字符串生成器适用于闭包。<strong>index</strong> 在多个函数调用之间保留,定义的内部函数可以访问在父函数中定义的变量。这是一个不同的作用域。如果在第二级函数中再定义一个函数，它可以访问所有父级变量。</p>\n<h3>4) this (全局域、函数域、对象域)</h3>\n<p>在 JavaScript 中，我们总是用函数和对象编写代码， 如果使用浏览器，则在全局上下文中它引用 <strong>window</strong> 对象。 我的意思是，如果你现在打开浏览器控制台并输入以下代码，输出结果为 <strong>true</strong>。</p>\n<pre class=\"prettyprint language-javascript\"><code>this === window;\n</code></pre><p>当程序的上下文和作用域发生变化时，<strong>this</strong> 也会发生相应的变化。现在观察 <strong>this</strong> 在一个局部上下文中：</p>\n<pre class=\"prettyprint language-javascript\"><code>function Foo(){\n  console.log(this.a);\n}\nvar food = {a: &quot;Magical this&quot;};\nFoo.call(food); &#x2F;&#x2F; food is this\n</code></pre><p>思考一下，以下输出的是什么：</p>\n<pre class=\"prettyprint language-javascript\"><code>function Foo(){\n    console.log(this); &#x2F;&#x2F; 打印 {}?\n}\n</code></pre><p>因为这是一个全局对象，记住，无论父作用域是什么，它都将由子作用域继承。打印出来是 window 对象。上面讨论的三个方法实际上用于设置这个对象。</p>\n<p>现在，<strong>this</strong> 的最后一个类型，在对象中的 <strong>this</strong>, 如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var person = {\n    name: &quot;Stranger&quot;,\n    age: 24,\n    get identity() {\n        return {who: this.name, howOld: this.age};\n    }\n}\n</code></pre><p>上述使用了 getter 语法，这是一个可以作为变量调用的函数。</p>\n<pre class=\"prettyprint language-javascript\"><code>person.identity; &#x2F;&#x2F; returns {who: &quot;Stranger&quot;, howOld: 24}\n</code></pre><p>此时，<strong>this</strong> 实际上是指对象本身。正如我们前面提到的，它在不同的地方有不同的表现。</p>\n<h3>5) 理解对象 (Object.freeze, Object.seal)</h3>\n<p>通常对象的格式如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var marks = {physics: 98, maths:95, chemistry: 91};\n</code></pre><p>它是一个存储键、值对的映射。 javascript 对象有一个特殊的属性，可以将任何东西存储为一个值。这意味着我们可以将一个列表、另一个对象、一个函数等存储为一个值。</p>\n<p>可以用如下方式来创建对象：</p>\n<pre class=\"prettyprint language-javascript\"><code>var marks = {};\nvar marks = new Object();\n</code></pre><p>可以使用 <strong>JSON.stringify()</strong> 将一个对象转制成字符串，也可以用 <strong>JSON.parse</strong> 在将其转成对象。</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; returns &quot;{&quot;physics&quot;:98,&quot;maths&quot;:95,&quot;chemistry&quot;:91}&quot;\nJSON.stringify(marks);\n&#x2F;&#x2F; Get object from string\nJSON.parse(&#x27;{&quot;physics&quot;:98,&quot;maths&quot;:95,&quot;chemistry&quot;:91}&#x27;);\n</code></pre><p>使用 <strong>Object.keys</strong> 迭代对象：</p>\n<pre class=\"prettyprint language-javascript\"><code>var highScere = 0;\n\nfor (i of Object.keys(marks)) {\n  if (marks[i] &gt; highScore)\n    highScore = marks[i];\n}\n</code></pre><p><strong>Object.values</strong> 以数组的方式返回对象的值。</p>\n<p>对象上的其他重要函数有:</p>\n<ul>\n<li>Object.prototype(object)</li>\n<li>Object.freeze(function)</li>\n<li>Object.seal(function)</li>\n</ul>\n<p><strong>Object.prototype</strong> 上提供了许多应用上相关的函数，如下：</p>\n<p><strong>Object.prototype.hasOwnProperty</strong> 用于检查给定的属性/键是否存在于对象中。</p>\n<pre class=\"prettyprint language-javascript\"><code>marks.hasOwnProperty(&quot;physics&quot;); &#x2F;&#x2F; returns true\nmarks.hasOwnProperty(&quot;greek&quot;); &#x2F;&#x2F; returns false\n</code></pre><p><strong>Object.prototype.instanceof</strong> 判断给定对象是否是特定原型的类型。</p>\n<pre class=\"prettyprint language-javascript\"><code>function Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\nvar newCar = new Car(&#x27;Honda&#x27;, &#x27;City&#x27;, 2007);\nconsole.log(newCar instanceof Car); &#x2F;&#x2F; returns true\n</code></pre><p>使用 <strong>Object.freeze</strong> 可以冻结对象，以便不能修改对象现有属性。</p>\n<pre class=\"prettyprint language-javascript\"><code>var marks = {physics: 98, maths:95, chemistry: 91};\nfinalizedMarks = Object.freeze(marks);\nfinalizedMarks[&quot;physics&quot;] = 86; &#x2F;&#x2F; throws error in strict mode\nconsole.log(marks); &#x2F;&#x2F; {physics: 98, maths: 95, chemistry: 91}\n</code></pre><p>在这里，试图修改冻结后的 <code>physics</code> 的值，但 JavaScript不允许这样做。我们可以使用 <strong>Object.isFrozen</strong> 来判断，给定对象是否被冻结:</p>\n<pre class=\"prettyprint language-javascript\"><code>Object.isFrozen(finalizedMarks); &#x2F;&#x2F; returns true\n</code></pre><p><strong>Object.seal</strong> 与 <strong>Object.freeze</strong> 略有不同。 <strong>Object.seal()</strong> 方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要可写就可以改变。</p>\n<pre class=\"prettyprint language-javascript\"><code>var marks = {physics: 98, maths:95, chemistry: 91};\nObject.seal(marks);\ndelete marks.chemistry; &#x2F;&#x2F; returns false as operation failed\nmarks.physics = 95; &#x2F;&#x2F; Works!\nmarks.greek = 86; &#x2F;&#x2F; Will not add a new property\n</code></pre><p>同样， 可以使用 <strong>Object.isSealed</strong> 判断对象是否被密封。</p>\n<pre class=\"prettyprint language-javascript\"><code>Object.isSealed(marks); &#x2F;&#x2F; returns true\n</code></pre><p>在全局对象函数上还有许多其他重要的函数/方法，在<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\">这里</a>找到他们。</p>\n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>6) 理解原型继承</h3>\n<p>在传统 JavaScript 中，有一种伪装的继承概念，它是通过使用原型技术来实现的。在ES5、ES6中看到使用 <strong>new</strong> 的语法只是底层原型OOP的语法糖。创建类是使用 JavaScript 中的函数完成的。</p>\n<pre class=\"prettyprint language-javascript\"><code>var animalGroups = {\n  MAMMAL: 1,\n  REPTILE: 2,\n  AMPHIBIAN: 3,\n  INVERTEBRATE: 4\n};\nfunction Animal(name, type) {\n  this.name = name;\n  this.type = type;\n}\nvar dog = new Animal(&quot;dog&quot;, animalGroups.MAMMAL);\nvar crocodile = new Animal(&quot;crocodile&quot;, animalGroups.REPTILE);\n</code></pre><p>这里我们为类创建对象(使用 <strong>new</strong> 关键字)，可以使用如下方式对类追加方法：</p>\n<pre class=\"prettyprint language-javascript\"><code>Animal.prototype.shout = function() {\n  console.log(this.name+&#x27;is&#x27;+this.sound+&#x27;ing...&#x27;);\n}\n</code></pre><p>这里你可能会有疑问。类中并没 <strong>sound</strong> 属性。是的，它打算由继承了上述类的子类传递。</p>\n<p>JavaScript中， 如下实现继承：</p>\n<pre class=\"prettyprint language-javascript\"><code>function Dog(name, type) {\nAnimal.call(this, name, type);\nthis.sound = &#x27;bow&#x27;;\n}\n</code></pre><p>我定义了一个更具体的函数，叫做 <strong>Dog</strong>。在这里，为了继承 <strong>Animal</strong> 类，我需要call传递this和其他参数。使用如下方式来实例化一只<code>德国牧羊犬</code>。</p>\n<pre class=\"prettyprint language-javascript\"><code>var pet = Dog(&quot;德国牧羊犬&quot;, animalGroups.MAMMAL);\nconsole.log(pet); &#x2F;&#x2F; returns Dog {name: &quot;德国牧羊犬&quot;, type: 1, sound: &quot;bow&quot;}\n</code></pre><p>我们没有在子函数中分配 <code>name</code> 和 <code>type</code> 属性，我们调用的是超级函数 Animal 并设置相应的属性。<strong>pet</strong> 具有父类的属性(name、type)。但是方法呢。他们也继承的吗? 来看看：</p>\n<pre class=\"prettyprint language-javascript\"><code>pet.shout(); &#x2F;&#x2F; Throws error\n</code></pre><p>为什么会这样？ 之所以发生这种情况，是因为没有指定让 JavaScript来继承父类方法。 如何解决？</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; Link prototype chains\nDog.prototype = Object.create(Animal.prototype);\nvar pet = new Dog(&quot;germanShepard&quot;, animalGroups.MAMMAL);\n&#x2F;&#x2F; Now shout method is available\npet.shout(); &#x2F;&#x2F; 德国牧羊犬 bowing...\n</code></pre><p>现在可以使用 <code>shout</code> 方法。 我们可以使用 <strong>object.constructor</strong> 函数检查 JavaScript 中给定对象的类 来看看 <strong>pet</strong> 是什么类:</p>\n<pre class=\"prettyprint language-javascript\"><code>pet.constructor; &#x2F;&#x2F; returns Animal\n</code></pre><p>这是模糊的,<strong>Animal</strong> 是一个父类。但是 <strong>pet</strong> 到底是什么类型的呢? <strong>pet</strong> 应该是 <code>Dog</code> 的类型。之所以是 <strong>Animal</strong> 类型，是因为 <strong>Dog</strong> 类的构造函数：</p>\n<pre class=\"prettyprint language-javascript\"><code>Dog.prototype.constructor; &#x2F;&#x2F; returns Animal\n</code></pre><p>它是 <strong>Animal</strong> 类型的。我们应该将它设置为 <strong>Dog</strong> 本身，这样类的所有实例(对象)才能给出正确的类名。</p>\n<pre class=\"prettyprint language-javascript\"><code>Dog.prototype.constructor = Dog;\n</code></pre><p>关于原型继承， 我们应该记住以下几条：</p>\n<ul>\n<li>类属性使用 <code>this</code> 绑定</li>\n<li>类方法使用 <code>prototype</code> 对象来绑定</li>\n<li>为了继承属性， 使用 <code>call</code> 函数来传递 <code>this</code></li>\n<li>为了继承方法, 使用 <strong>Object.create</strong> 连接父和子的原型</li>\n<li>始终将子类构造函数设置为自身，以获得其对象的正确类型</li>\n</ul>\n<h2>7）理解 callback 和 promise</h2>\n<p>回调是在 I/O 操作完成后执行的函数。一个耗时的I/O操作会阻塞代码， 因此在Python/Ruby不被允许。但是在 JavaScript中，由于允许异步执行，我们可以提供对异步函数的回调。这个例子是由浏览器到服务器的AJAX(XMLHettpRequest)调用，由鼠标、键盘事件生成。如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>function reqListener () {\n  console.log(this.responseText);\n}\n\nvar req = new XMLHttpRequest();\nreq.addEventListener(&quot;load&quot;, reqListener);\nreq.open(&quot;GET&quot;, &quot;http:&#x2F;&#x2F;www.example.org&#x2F;example.txt&quot;);\nreq.send();\n</code></pre><p>这里的 <strong>reqListener</strong> 是一个回调函数，当成功响应 <strong>GET</strong> 请求时将执行该回调函数。</p>\n<p>Promise 是回调函数的优雅的封装， 使得我们优雅的实现异步代码。在以下给出的这篇文章中讨论了很多 <strong>promise</strong>,这也是在 JS 中应该知道的重要部分。</p>\n<p><a href=\"https://medium.com/dev-bits/writing-neat-asynchronous-node-js-code-with-promises-32ed3a4fd098\">Writing neat asynchronous Node JS code with Promises</a></p>\n<h2>8）理解正则表达</h2>\n<p>正则表达式有许多应用地方，处理文本、对用户输入执行规则等。JavaScript 开发人员应该知道如何执行基本正则表达式并解决问题。<strong>Regex</strong> 是一个通用概念，来看看如何从 JS 中做到这一点。</p>\n<p>创建正则表达式，有如下两种方式：</p>\n<pre class=\"prettyprint language-javascript\"><code>var re = &#x2F;ar&#x2F;;\nvar re = new RegExp(&#x27;ar&#x27;); \n</code></pre><p>上面的正则表达式是与给定字符串集匹配的表达式。定义正则表达式之后，我们可以尝试匹配并查看匹配的字符串。可以使用 <strong>exec</strong> 函数匹配字符串:</p>\n<pre class=\"prettyprint language-javascript\"><code>re.exec(&quot;car&quot;); &#x2F;&#x2F; returns [&quot;ar&quot;, index: 1, input: &quot;car&quot;]\nre.exec(&quot;cab&quot;); &#x2F;&#x2F; returns null\n</code></pre><p>有一些特殊的字符类允许我们编写复杂的正则表达式。<strong>RegEx</strong> 中有许多类型的元素，其中一些如下:</p>\n<ul>\n<li>字符正则：<code>\\w</code>-字母数字， <code>\\d</code>- 数字， <code>\\D</code>- 没有数字</li>\n<li>字符类正则：[<code>x-y]</code> x-y区间， <code>[^x]</code> 没有x</li>\n<li>数量正则：<code>+</code> 至少一个、<code>?</code> 没或多个、<code>*</code> 多个</li>\n<li>边界正则，<code>^</code> 开始、<code>$</code> 结尾</li>\n</ul>\n<p>例子如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;* Character class *&#x2F;\n\nvar re1 = &#x2F;[AEIOU]&#x2F;;\nre1.exec(&quot;Oval&quot;); &#x2F;&#x2F; returns [&quot;O&quot;, index: 0, input: &quot;Oval&quot;]\nre1.exec(&quot;2456&quot;); &#x2F;&#x2F; null\nvar re2 = &#x2F;[1-9]&#x2F;;\nre2.exec(&#x27;mp4&#x27;); &#x2F;&#x2F; returns [&quot;4&quot;, index: 2, input: &quot;mp4&quot;]\n\n&#x2F;* Characters *&#x2F;\n\nvar re4 = &#x2F;\\d\\D\\w&#x2F;;\nre4.exec(&#x27;1232W2sdf&#x27;); &#x2F;&#x2F; returns [&quot;2W2&quot;, index: 3, input: &quot;1232W2sdf&quot;]\nre4.exec(&#x27;W3q&#x27;); &#x2F;&#x2F; returns null\n\n&#x2F;* Boundaries *&#x2F;\n\nvar re5 = &#x2F;^\\d\\D\\w&#x2F;;\nre5.exec(&#x27;2W34&#x27;); &#x2F;&#x2F; returns [&quot;2W3&quot;, index: 0, input: &quot;2W34&quot;]\nre5.exec(&#x27;W34567&#x27;); &#x2F;&#x2F; returns null\nvar re6 = &#x2F;^[0-9]{5}-[0-9]{5}-[0-9]{5}$&#x2F;;\nre6.exec(&#x27;23451-45242-99078&#x27;); &#x2F;&#x2F; returns [&quot;23451-45242-99078&quot;, index: 0, input: &quot;23451-45242-99078&quot;]\nre6.exec(&#x27;23451-abcd-efgh-ijkl&#x27;); &#x2F;&#x2F; returns null\n\n&#x2F;* Quantifiers *&#x2F;\n\nvar re7 = &#x2F;\\d+\\D+$&#x2F;;\nre7.exec(&#x27;2abcd&#x27;); &#x2F;&#x2F; returns [&quot;2abcd&quot;, index: 0, input: &quot;2abcd&quot;]\nre7.exec(&#x27;23&#x27;); &#x2F;&#x2F; returns null\nre7.exec(&#x27;2abcd3&#x27;); &#x2F;&#x2F; returns null\nvar re8 = &#x2F;&lt;([\\w]+).*&gt;(.*?)&lt;\\&#x2F;\\1&gt;&#x2F;;\nre8.exec(&#x27;&lt;p&gt;Hello JS developer&lt;&#x2F;p&gt;&#x27;); &#x2F;&#x2F;returns  [&quot;&lt;p&gt;Hello JS developer&lt;&#x2F;p&gt;&quot;, &quot;p&quot;, &quot;Hello JS developer&quot;, index: 0, input: &quot;&lt;p&gt;Hello JS developer&lt;&#x2F;p&gt;&quot;]\n</code></pre><p>有关 regex 的详细信息，可以看 <a href=\"http://www.rexegg.com/regex-quickstart.html\">这里</a>。</p>\n<p>除了 <strong>exec</strong> 之外，还有其他函数，即 <strong>match</strong>、<strong>search</strong> 和 <strong>replace</strong>，可以使用正则表达式在另一个字符串中查找字符串，但是这些函数在字符串本身上使用。</p>\n<pre class=\"prettyprint language-javascript\"><code>&quot;2345-678r9&quot;.match(&#x2F;[a-z A-Z]&#x2F;); &#x2F;&#x2F; returns [&quot;r&quot;, index: 8, input: &quot;2345-678r9&quot;]\n&quot;2345-678r9&quot;.replace(&#x2F;[a-z A-Z]&#x2F;, &quot;&quot;); &#x2F;&#x2F; returns 2345-6789\n</code></pre><p>Regex 是一个重要的主题，开发人员应该理解它，以便轻松解决复杂的问题。</p>\n<h3>9）理解 map、reduce 和 filter</h3>\n<p>函数式编程是当今的一个热门讨论话题。许多编程语言都在新版本中包含了函数概念，比如 lambdas(例如:Java &gt;7)。在 JavaScrip t中，函数式编程结构的支持已经存在很长时间了。我们需要深入学习三个主要函数。数学函数接受一些输入和返回输出。纯函数都是给定的输入返回相同的输出。我们现在讨论的函数也满足纯度。</p>\n<h4>map</h4>\n<p>map 函数在 JavaScript 数组中可用,使用这个函数，我们可以通过对数组中的每个元素应用一个转换函数来获得一个新的数组。<strong>map</strong> 一般语法是:</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.map((elem){\n    process(elem)\n    return processedValue\n}) &#x2F;&#x2F; returns new array with each element processed\n</code></pre><p>假设，在我们最近使用的串行密钥中输入了一些不需要的字符，需要移除它们。此时可以使用 <strong>map</strong> 来执行相同的操作并获取结果数组，而不是通过迭代和查找来删除字符。</p>\n<pre class=\"prettyprint language-javascript\"><code>var data = [&quot;2345-34r&quot;, &quot;2e345-211&quot;, &quot;543-67i4&quot;, &quot;346-598&quot;];\nvar re = &#x2F;[a-z A-Z]&#x2F;;\nvar cleanedData = data.map((elem) =&gt; {return elem.replace(re, &quot;&quot;)});\nconsole.log(cleanedData); &#x2F;&#x2F; [&quot;2345-34&quot;, &quot;2345-211&quot;, &quot;543-674&quot;, &quot;346-598&quot;]\n</code></pre><p><strong>map</strong> 接受一个作为参数的函数， 此函数接受一个来自数组的参数。我们需要返回一个处理过的元素， 并应用于数组中的所有元素。</p>\n<h4>reduce</h4>\n<p><strong>reduce</strong> 函数将一个给定的列表整理成一个最终的结果。通过迭代数组执行相同的操作， 并保存中间结果到一个变量中。这里是一个更简洁的方式进行处理。js 的 <strong>reduce</strong> 一般使用语法如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.reduce((accumulator,\n           currentValue,\n           currentIndex) =&gt; {\n           process(accumulator, currentValue)\n           return intermediateValue&#x2F;finalValue\n}, initialAccumulatorValue) &#x2F;&#x2F; returns reduced value\n</code></pre><p><strong>accumulator</strong> 存储中间值和最终值。<strong>currentIndex</strong>、<strong>currentValue</strong>分别是数组中元素的 index 和 value。<strong>initialAccumulatorValue</strong> 是 <strong>accumulator</strong> 初始值。</p>\n<p><strong>reduce</strong> 的一个实际应用是将一个数组扁平化， 将内部数组转化为单个数组， 如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>var arr = [[1, 2], [3, 4], [5, 6]];\nvar flattenedArray = [1, 2, 3, 4, 5, 6];\n</code></pre><p>我们可以通过正常的迭代来实现这一点，但是使用 <strong>reduce</strong>，代码会更加简洁。</p>\n<pre class=\"prettyprint language-javascript\"><code>var flattenedArray = arr.reduce((accumulator, currentValue) =&gt; {\n    return accumulator.concat(currentValue);\n}, []); &#x2F;&#x2F; returns [1, 2, 3, 4, 5, 6]\n</code></pre><h4><strong>filter</strong></h4>\n<p><strong>filter</strong> 与 <strong>map</strong> 更为接近， 对数组的每个元素进行操作并返回另外一个数组（不同于 <strong>reduce</strong> 返回的值）。过滤后的数组可能比原数组长度更短，因为通过过滤条件，排除了一些我们不需要的。</p>\n<p><strong>filter</strong> 语法如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>arr.filter((elem) =&gt; {\n   return true&#x2F;false\n})\n</code></pre><p><strong>elem</strong> 是数组中的元素， 通过 <code>true/false</code> 表示过滤元素保存/排除。假设， 我们过滤出以 <code>t</code> 开始以 <code>r</code> 结束的元素：</p>\n<pre class=\"prettyprint language-javascript\"><code>var words = [&quot;tiger&quot;, &quot;toast&quot;, &quot;boat&quot;, &quot;tumor&quot;, &quot;track&quot;, &quot;bridge&quot;]\nvar newData = words.filter((str) =&gt; {\n    return str.startsWith(&#x27;t&#x27;) &amp;&amp; str.endsWith(&#x27;r&#x27;);\n})\nnewData &#x2F;&#x2F; (2) [&quot;tiger&quot;, &quot;tumor&quot;]\n</code></pre><p>当有人问起JavaScript的函数编程方面时，这三个函数应该信手拈来。 如你所见，原始数组在所有三种情况下都没有改变，这证明了这些函数的纯度。</p>\n<h2>10) 理解错误处理模式</h2>\n<p>这是许多开发人员最不关心的 JavaScript。 我看到很少有开发人员谈论错误处理， 一个好的开发方法总是谨慎地将 JS 代码封装装在 <code>try/catch</code> 块周围。</p>\n<p>在 JavaScript中，只要我们随意编写代码，就可能会失败，如果所示:</p>\n<pre class=\"prettyprint language-javascirpt\"><code>$(&quot;button&quot;).click(function(){\n    $.ajax({url: &quot;user.json&quot;, success: function(result){\n        updateUI(result[&quot;posts&quot;]);\n    }});\n});\n</code></pre><p>这里，我们陷入了一个陷阱，我们说 <strong>result</strong> 总是 JSON 对象。但有时服务器会崩溃，返回的是 <strong>null</strong> 而不是 <strong>result</strong>。在这种情况下，<code>null[&quot;posts&quot;]</code> 将抛出一个错误。正确的处理方式可能是这样的：</p>\n<pre class=\"prettyprint language-javascript\"><code>$(&quot;button&quot;).click(function(){\n    $.ajax({url: &quot;user.json&quot;, success: function(result){\n    \n      try {     \n        updateUI(result[&quot;posts&quot;]);\n       }\n      catch(e) {\n        &#x2F;&#x2F; Custom functions\n        logError();\n        flashInfoMessage();      \n      }\n    }});\n});\n</code></pre><p><strong>logError</strong> 函数用于向服务器报告错误。<strong>flashInfoMessage</strong> 是显示用户友好的消息，如“当前不可用的服务”等。</p>\n<p>Nicholas 说，当你觉得有什么意想不到的事情将要发生时，手动抛出错误。区分致命错误和非致命错误。以上错误与后端服务器宕机有关，这是致命的。在那里，应该通知客户由于某种原因服务中断了。</p>\n<p>在某些情况下，这可能不是致命的，但最好通知服务器。为了创建这样的代码，首先抛出一个错误，， 从 <strong>window</strong> 层级捕捉错误事件，然后调用API将该消息记录到服务器。</p>\n<pre class=\"prettyprint language-javascript\"><code>reportErrorToServer = function (error) {\n  $.ajax({type: &quot;POST&quot;, \n          url: &quot;http:&#x2F;&#x2F;api.xyz.com&#x2F;report&quot;,\n          data: error,\n          success: function (result) {}\n  });\n}\n&#x2F;&#x2F; Window error event\nwindow.addEventListener(&#x27;error&#x27;, function (e) {\n  reportErrorToServer({message: e.message})\n})}\nfunction mainLogic() {\n  &#x2F;&#x2F; Somewhere you feel like fishy\n  throw new Error(&quot;user feeds are having fewer fields than expected...&quot;);\n}\n</code></pre><p>这段代码主要做三件事:</p>\n<ul>\n<li>监听window层级错误</li>\n<li>无论何时发生错误，都要调用 API</li>\n<li>在服务器中记录</li>\n</ul>\n<p>你也可以使用新的 <strong>Boolean</strong> 函数（es5，es6）在程序之前监测变量的有效性并且不为null、undefined</p>\n<pre class=\"prettyprint language-javascript\"><code>if (Boolean(someVariable)) {\n&#x2F;&#x2F; use variable now\n} else {\n    throw new Error(&quot;Custom message&quot;)\n}\n</code></pre><p>始终考虑错误处理是你自己， 而不是浏览器。</p>\n<h3>其他(提升机制和事件冒泡)</h3>\n<p>以上所有概念都是 JavaScript 开发人员的需要知道基本概念。有一些内部细节需要知道，这些对你会有很在帮助。 这些是JavaScript引擎在浏览器中的工作方式，什么是提升机制和事件冒泡？</p>\n<h4><strong>提升机制</strong></h4>\n<p>变量提升是 在代码执行过程中将声明的变量的作用域提升到全局作用哉中的一个过程，如：</p>\n<pre class=\"prettyprint language-javascript\"><code>doSomething(foo); &#x2F;&#x2F; used before\nvar foo; &#x2F;&#x2F; declared later\n</code></pre><p>当在 <strong>Python</strong> 这样的脚本语言中执行上述操作时，它会抛出一个错误，因为需要先定义然后才能使用它。尽管 JS 是一种脚本语言，但它有一种提升机制，在这种机制中，JavaScript VM 在运行程序时做两件事:</p>\n<ul>\n<li>首先扫描程序，收集所有的变量和函数声明，并为其分配内存空间</li>\n<li>通过填充分配的变量来执行程序， 没有分配则填充 <code>undefined</code></li>\n</ul>\n<p>在上面的代码片段中，<code>console.log</code> 打印 <code>“undefined”</code>。 这是因为在第一次传递变量 <strong>foo</strong> 被收集。 JS 虚拟机 查找为变量 <strong>foo</strong> 定义的任何值。 这种提升可能导致许多JavaScript 在某些地方抛出错误，和另外地方使用 <code>undefined</code> 。</p>\n<p>学习一些 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Hoisting\">例子</a> 来搞清楚提升。</p>\n<h4><strong>事件冒泡</strong></h4>\n<p>现在事件开始冒泡了! 根据高级软件工程师 Arun P的说法:</p>\n<blockquote>\n<p>“当事件发生在另一个元素内的元素中时，事件冒泡和捕获是 HTML DOM API 中事件传播的两种方式，并且这两个元素都已为该事件注册了处理程序，事件传播模式确定元素接收事件的顺序。“</p>\n</blockquote>\n<p>通过冒泡，事件首先由最内部的元素捕获和处理，然后传播到外部元素。对于捕获，过程是相反的。我们通常使用<strong>addEventListener</strong> 函数将事件附加到处理程序。</p>\n<pre class=\"prettyprint language-javascript\"><code>addEventListener(&quot;click&quot;, handler, useCapture=false)\n</code></pre><p><strong>useCapture</strong> 是第三个参数的关键词， 默认为 <code>false</code>。因此， 冒泡模式是事件由底部向上传递。 反之， 这是捕获模式。</p>\n<p><strong>冒泡模式：</strong></p>\n<pre class=\"prettyprint language-html\"><code>&lt;div onClick=&quot;divHandler()&quot;&gt;\n    &lt;ul onClick=&quot;ulHandler&quot;&gt;\n        &lt;li id=&quot;foo&quot;&gt;&lt;&#x2F;li&gt;\n    &lt;&#x2F;ul&gt;\n&lt;&#x2F;div&gt;\n&lt;script&gt;\nfunction handler() {\n &#x2F;&#x2F; do something here\n}\nfunction divHandler(){}\nfunction ulHandler(){}\ndocument.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;, handler)\n&lt;&#x2F;script&gt;\n</code></pre><p>点击li元素， 事件顺序：</p>\n<p>handler() =&gt; ulHandler() =&gt; divHandler()</p>\n<p><img src=\"https://image.fundebug.com/2019-02-21-001.png\" alt></p>\n<p>在图中，处理程序按顺序向外触发。类似地，捕获模型试图将事件从父元素向内触发到单击的元素。现在更改上面代码中的这一行。</p>\n<pre class=\"prettyprint language-javascript\"><code>document.getElementById(&quot;foo&quot;).addEventListener(&quot;click&quot;, handler, true)\n</code></pre><p>事件顺序：</p>\n<pre class=\"prettyprint language-javascript\"><code>divHandler =&gt; ulHandler() =&gt; handler()\n</code></pre><p><img src=\"https://image.fundebug.com/2019-02-21-002.png\" alt></p>\n<p>你应该正确地理解事件冒泡(无论方向是指向父节点还是子节点)，以实现用户界面(UI)，以避免任何不需要的行为。</p>\n<p>这些是 JavaScript中的基本概念。正如我最初提到的，除了工作经验和知识之外，准备有助理于你通过 JavaScript 面试。始终保持学习。留意最新的发展(第六章)。深入了解JavaScript的各个方面，如 V6 引擎、测试等。最后，没有掌握数据结构和算法的面试是不成功的。<a href=\"https://github.com/trekhleb\">Oleksii Trekhleb</a> 策划了一个很棒的 git repo，它包含了所有使用 JS 代码的面试准备算法。</p>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n</div>","title":"JavaScript面试的完美指南(开发者视角)","last_reply_at":"2019-02-21T10:14:16.679Z","good":false,"top":false,"reply_count":3,"visit_count":438,"create_at":"2019-02-21T03:38:16.900Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c6a7af354155543f0ba5419","author_id":"570b651894b38dcb3c09a823","tab":"share","content":"<div class=\"markdown-text\"><h1>Mokia</h1>\n<p><a href=\"https://github.com/varHarrie/mokia\">仓库地址</a></p>\n<p>一个集成了数据模拟和HTTP服务的Mock工具。</p>\n<h2>特性</h2>\n<ul>\n<li>🤟 简单易用</li>\n<li>🔄 模型可复用</li>\n<li>💎 支持TypeScript</li>\n</ul>\n<h2>安装</h2>\n<pre class=\"prettyprint language-bash\"><code>$ npm install mokia --save-dev\n# 或者\n$ yarn add mokia --dev\n</code></pre><h2>基本用法</h2>\n<ol>\n<li>添加一个文件，比如“mock.ts”：</li>\n</ol>\n<pre class=\"prettyprint language-typescript\"><code>import { mock, PORT, ServerConfig } from &#x27;mokia&#x27;\n\nconst config: ServerConfig = {\n  [PORT]: 3000,\n  &#x27;GET &#x2F;users&#x27;: () =&gt; {\n    return {\n      users: mock.array({\n        id: mock.uuid(),\n        name: mock.fullName()\n      }, 0, 5)\n    }\n  },\n  &#x27;GET &#x2F;users&#x2F;:id&#x27;: () =&gt; {\n    return {\n      id: mock.uuid(),\n      name: mock.fullName()\n    }\n  }\n}\n\nexport default config\n</code></pre><ol>\n<li>运行脚本启动服务器：</li>\n</ol>\n<pre class=\"prettyprint language-bash\"><code>$ npx mokia mock.ts\n</code></pre><h2>进阶用法</h2>\n<p>为了较少重复代码和保持代码复用性，我们推荐使用JS类风格书写：</p>\n<pre class=\"prettyprint language-typescript\"><code>import { decorators, mock, PORT, ServerConfig } from &#x27;mokia&#x27;\n\nclass User {\n  decorators.uuid()\n  id: string\n\n  decorators.fullName()\n  name: string\n}\n\nconst config: ServerConfig = {\n  [PORT]: 3000,\n  &#x27;GET &#x2F;users&#x27;: () =&gt; {\n    return {\n      users: mock.array(User, 0, 5)\n    }\n  },\n  &#x27;GET &#x2F;users&#x2F;:id&#x27;: () =&gt; {\n    return mock(User)\n  }\n}\n\nexport default config\n</code></pre><h2>APIs</h2>\n<h3>服务器配置参数：</h3>\n<ul>\n<li><code>HOST</code> 服务器主机，默认为<code>'localhost'</code></li>\n<li><code>PORT</code> 服务器端口号，默认为<code>8080</code></li>\n<li><code>PREFIX</code> URL前缀，默认为<code>''</code></li>\n<li><code>SILENT</code> 是否隐藏请求日志，默认为<code>false</code></li>\n</ul>\n<p>注意：这些参数传入时都不是字符串，而是<code>Symbol</code>，你应该从<code>mokia</code>包中引入。</p>\n<pre class=\"prettyprint language-typescript\"><code>import { PORT } from &#x27;mokia&#x27;\n\nexport default {\n  [HOST]: &#x27;localhost&#x27;,\n  [PORT]: 3000,\n  [PREFIX]: &#x27;&#x2F;apis&#x27;,\n  [SILENT]: true,\n  &#x2F;&#x2F; ...\n}\n</code></pre><h3>随机生成器</h3>\n<pre class=\"prettyprint\"><code>[已支持生成器列表](https:&#x2F;&#x2F;github.com&#x2F;varHarrie&#x2F;mokia&#x2F;blob&#x2F;master&#x2F;README.zh-cn.md#%E7%94%9F%E6%88%90%E5%99%A8)</code></pre></div>","title":"一个简单易用的mock工具库——mokia","last_reply_at":"2019-02-21T06:17:20.379Z","good":false,"top":false,"reply_count":1,"visit_count":462,"create_at":"2019-02-18T09:29:23.814Z","author":{"loginname":"varHarrie","avatar_url":"https://avatars1.githubusercontent.com/u/14304201?v=4&s=120"}},{"id":"5c6cca1633b0b629ac843197","author_id":"53be3c03a3ccaece73ba0606","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/danielsss/mail-sc.js\">请不要吝啬您的 Star，您的支持便是对本人最大的鼓励。非常感谢</a></p>\n<p>A wrapped email sdk for <a href=\"https://www.sendcloud.net\">SendCloud</a></p>\n<p>Welcome PRs.</p>\n<h2>Requirements</h2>\n<ul>\n<li>Node.js &gt; v7.0.*</li>\n</ul>\n<h2>Dependencies</h2>\n<ul>\n<li>axios</li>\n<li>debug</li>\n</ul>\n<h2>Installation</h2>\n<pre class=\"prettyprint language-shell\"><code>npm i --save mail-sc.js\n</code></pre><h2>Usage</h2>\n<h4>Example 1: <a href=\"#aliases\">Recommended. See APIs</a></h4>\n<pre class=\"prettyprint language-js\"><code>const {\n  createClient, decomposeAddress, addressParser\n} = require(&#x27;mail-sc.js&#x27;);\nconst options = {apiKey: &#x27;your key&#x27;, apiUser: &#x27;your user&#x27;};\nconst sendCloud = createClient(options);\n\nconst address = &#x27;tester&lt;test_address@test.com&gt;&#x27;;\nconst decomposed = decomposeAddress(address);\n\nconst addr1 = [&#x27;test1@test.com&#x27;, &#x27;test2@test.com&#x27;];\nconst addr2 = &#x27;test1@test.com, test2@test.com,         test3@test.com&#x27;;\n\nconsole.log(addressParser(addr1));\n&#x2F;&#x2F; &#x27;test1@test.com;test2@test.com&#x27;\n\nconsole.log(addressParser(addr2, &#x27;,&#x27;));\n&#x2F;&#x2F; &#x27;test1@test.com;test2@test.com;test3@test.com&#x27;\n\nconst message = {\n  from: decomposed.address,\n  fromName: decomposed.name,\n  to: &#x27;test1@test,com&#x27;,\n  subject: &#x27;test subject&#x27;,\n  html: &#x27;test message&#x27;\n};\nconst sendMessage = async () =&gt; {\n  return await sendCloud.delivery.send(message);\n}\nsendMessage();\n</code></pre><h4>Example 2</h4>\n<pre class=\"prettyprint language-js\"><code>const {\n  SendCloud, decomposeAddress\n} = require(&#x27;mail-sc.js&#x27;);\nconst options = {apiKey: &#x27;your key&#x27;, apiUser: &#x27;your user&#x27;};\nconst sendCloud = new SendCloud(options);\n\nconst address = &#x27;tester&lt;test_address@test.com&gt;&#x27;;\nconst decomposed = decomposeAddress(address);\n\nconst message = {\n  from: decomposed.address,\n  fromName: decomposed.name,\n  to: &#x27;test1@test,com&#x27;,\n  subject: &#x27;test subject&#x27;,\n  html: &#x27;test message&#x27;\n};\nconst sendMessage = async () =&gt; {\n  return await sendCloud.send(message);\n}\n\nsendMessage();\n</code></pre><h2>SendCloud Options</h2>\n<ul>\n<li><code>apiKey</code> - The send cloud apiKey</li>\n<li><code>apiUser</code> - The send cloud apiUser</li>\n<li><code>host</code> - The hostname of send cloud api [<code>default</code>: <a href=\"http://api.sendcloud.net\">api.sendcloud.net</a>]</li>\n<li><code>protocol</code> - http|https [<code>default</code>: http]</li>\n<li><code>port</code> - [<code>default</code>: 80]</li>\n<li><code>retry</code> - [<code>default</code>: 1]</li>\n<li><code>proxy</code> - axios proxy [<code>default</code>: null]</li>\n<li><code>timeout</code> - axios timeout [<code>default</code>: 1000 * 6]</li>\n</ul>\n<h2>SendCloud Methods</h2>\n<h4>Deliveries</h4>\n<ul>\n<li><strong>.send(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/send_email/#regular-delivery\">Regular delivery</a></li>\n<li><strong>.sendTemplate(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/send_email/#template-delivery\">Template delivery</a></li>\n<li><strong>.sendCalendar(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/send_email/#send-meeting-calendar\">Send meeting calendar</a></li>\n<li><strong>.taskInfo(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/send_email/#http-request-method\">List task info</a></li>\n</ul>\n<h4>Email Template</h4>\n<ul>\n<li><strong>.batchQuery(Object)</strong>   -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#query-batch-query\">Basic information of returned email template</a></li>\n<li><strong>.query(Object)</strong>    -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#query\">Detailed information of returned email template</a></li>\n<li><strong>.add(Object)</strong>  -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#add\">Adding template to sendCloud</a></li>\n<li><strong>.delete(Object)</strong>   -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#query-batch-query\">Deleting email template from sendCloud</a></li>\n<li><strong>.modification(Object)</strong> -   <a href=\"http://www.sendcloud.net/doc/en/email_v2/template_do/#modification\">Name, content, subject and type of the template can be modified.</a></li>\n</ul>\n<h4>Address List</h4>\n<ul>\n<li><strong>.batchQueryAddressList(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/\">Query address list (batch query)</a></li>\n<li><strong>.addAddressList(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#add-address-list\">Adding address to list</a></li>\n<li><strong>.deleteAddressList(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#delete-address-list\">Deleting address list</a></li>\n<li><strong>.modifyAddressList(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#modify-address-list\">Modify address list or update address list</a></li>\n<li><strong>.batchQueryListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#query-list-member-batch-query\">Query list member (batch query)</a></li>\n<li><strong>.queryListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#query-list-member\">Query list member</a></li>\n<li><strong>.addListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#add-list-member\">Add list member</a></li>\n<li><strong>.modifyListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#modify-list-member\">Modify list member</a></li>\n<li><strong>.deleteListMember(Object)</strong>\t-\t<a href=\"http://www.sendcloud.net/doc/en/email_v2/list_do/#delete-list-member\">Delete list member</a></li>\n</ul>\n<h2>Aliases</h2>\n<ul>\n<li>all the method’s parameter same to <a href=\"#sendcloud-methods\">here</a></li>\n</ul>\n<h4>Deliveries</h4>\n<ul>\n<li><strong>delivery.send(Object)}</strong></li>\n<li><strong>delivery.sendTemplate(Object)}</strong></li>\n<li><strong>delivery.sendCalendar(Object)}</strong></li>\n<li><strong>delivery.taskInfo(Object)}</strong></li>\n</ul>\n<h4>Email Template</h4>\n<ul>\n<li><strong>template.batchQuery(Object)}</strong></li>\n<li><strong>template.query(Object)}</strong></li>\n<li><strong>template.add(Object)}</strong></li>\n<li><strong>template.delete(Object)}</strong></li>\n<li><strong>template.update(Object)}</strong></li>\n</ul>\n<h4>Address List</h4>\n<ul>\n<li><strong>addressList.batchQueryAddress(Object)}</strong></li>\n<li><strong>addressList.addAddress(Object)}</strong></li>\n<li><strong>addressList.deleteAddress(Object)}</strong></li>\n<li><strong>addressList.updateAddress(Object)}</strong></li>\n<li><strong>addressList.batchQueryMember(Object)}</strong></li>\n<li><strong>addressList.queryMember(Object)}</strong></li>\n<li><strong>addressList.addMember(Object)}</strong></li>\n<li><strong>addressList.updateMember(Object)}</strong></li>\n<li><strong>addressList.deleteMember(Object)}</strong></li>\n</ul>\n<h2>Planning implementations</h2>\n<h4>SendCloud APIs</h4>\n<ul>\n<li>[x] Deliveries</li>\n<li>[x] Email Template</li>\n<li>[x] Address List</li>\n<li>[ ] Email Label</li>\n<li>[ ] Domain</li>\n<li>[ ] API_USER</li>\n<li>[ ] User Information</li>\n<li>[ ] Statistics</li>\n<li>[ ] Delivery Response</li>\n<li>[ ] Bounce List Management</li>\n<li>[ ] Unsubscribe Management</li>\n<li>[ ] Spam Report Management</li>\n<li>[ ] Lists of Opens And Clicks Management</li>\n</ul>\n<h4>Build-in utilities</h4>\n<ul>\n<li>[x] .addressParser(addresses, tag) - Normalizing email address list or email string list</li>\n<li>[x] .decomposeAddress(address) - Decomposing an email address into fromName &amp; address</li>\n</ul>\n<ul>\n<li><a href=\"#example-1-recommended-see-apisaliases\">See details for utilities usage</a></li>\n</ul>\n</div>","title":"基于国内 SendCloud 平台实现的邮件相关 SDK。欢迎 PR 并求 star","last_reply_at":"2019-02-21T04:42:39.196Z","good":false,"top":false,"reply_count":3,"visit_count":286,"create_at":"2019-02-20T03:31:34.203Z","author":{"loginname":"danielsss","avatar_url":"https://avatars3.githubusercontent.com/u/5127897?v=4&s=120"}},{"id":"5b8de66137b3005a0b0e6b3f","author_id":"5b8de41bbf116a8c0e42579f","tab":"share","content":"<div class=\"markdown-text\"><p>Egg.js入门视频教程主要讲了Egg的环境搭建   egg的控制器      egg服务  egg中间件   egg路由 egg扩展   egg模板引擎  egg cookie   egg session</p>\n<p><strong>Eggjs 视频教程百度网盘分享接</strong>： <a href=\"https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w\">https://pan.baidu.com/s/1t6XHpny8-H8mApLkzcsS8w</a></p>\n<p><strong>或者此连接Egg.js视频教程10讲入门链接</strong>： <a href=\"https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg\">https://pan.baidu.com/s/1-jdCXKGgfk9yI8xJOOhPhg</a>  <strong>密码</strong>：4b6i</p>\n<p><strong>来源</strong>  <a href=\"https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf\">https://cnodejs.org/topic/5b7ac9c7c52ad1482eb940bf</a></p>\n<p>希望老铁门能喜欢\n<img src=\"//static.cnodejs.org/FoPZNWCMpHqWFAb2QDns-UhIMX-3\" alt=\"egg01.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fu4_-OevpWiKHFqeEGBOW53MCdnE\" alt=\"egg02.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtOEkaeRTUNyuWE2mhvazrxPc6cd\" alt=\"egg03.png\"></p>\n<p><img src=\"//static.cnodejs.org/FtJsuDe3kbcNYWWcJyfxuE08wVs5\" alt=\"egg05.png\"></p>\n<p><img src=\"//static.cnodejs.org/Fp8erhbPkGZrsYFsd-gxn2z4Gssb\" alt=\"222.png\"></p>\n<p><img src=\"//static.cnodejs.org/FhCAuCKVwbQnTCJWtkGKv6ZR8toN\" alt=\"06.png\"></p>\n</div>","title":"Egg.js视频教程-Eggjs入门视频教程网盘免费分享-10讲入门基础希望老铁门能喜欢","last_reply_at":"2019-02-21T03:55:19.690Z","good":false,"top":false,"reply_count":75,"visit_count":9212,"create_at":"2018-09-04T01:56:49.179Z","author":{"loginname":"zlyuanteng","avatar_url":"https://avatars0.githubusercontent.com/u/42952042?v=4&s=120"}},{"id":"5c60e10605cc322e7b137bef","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 理解JS继承。</p>\n<ul>\n<li>原文：<a href=\"https://segmentfault.com/a/1190000016542417\">搞懂 JavaScript 继承原理</a></li>\n<li>作者：<a href=\"https://segmentfault.com/a/1190000017794020\">前端小智</a></li>\n</ul>\n<p><strong><a href=\"https://www.fundebug.com/\">Fundebug</a>经授权转载，版权归原作者所有。</strong></p>\n<p>在理解继承之前，需要知道 js 的三个东西：</p>\n<ul>\n<li>\n<ol>\n<li>什么是 JS 原型链</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>this 的值到底是什么</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>JS 的 new 到底是干什么的</li>\n</ol>\n</li>\n</ul>\n<h3>1. 什么是 JS 原型链？</h3>\n<p>我们知道 JS 有对象，比如</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = { name: &quot;obj&quot; };\n</code></pre><p>我们通过控制台把 obj 打印出来：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-01.png\" alt></p>\n<p>我们会发现 obj 已经有几个属性（方法）了。<strong>那么问题来了：valueOf / toString / constructor 是怎么来？我们并没有给 obj.valueOf 赋值呀。</strong></p>\n<p>上面这个图有点难懂，我手画一个示意图：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-02.png\" alt></p>\n<p>我们发现控制台打出来的结果是：</p>\n<ul>\n<li>obj 本身有一个属性 name (这是我们给它加的)</li>\n<li>obj 还有一个属性叫做 <strong>proto</strong>(它是一个对象)</li>\n<li>obj 还有一个属性，包括 valueOf, toString, constructor 等</li>\n<li>obj.<strong>proto</strong>其实也有一个叫做<strong>proto</strong>的属性(console.log 没有显示)，值为 null</li>\n</ul>\n<p>现在回到我们的问题：obj 为什么会拥有 valueOf / toString / constructor 这几个属性？</p>\n<p><strong>答案： 这跟 <strong>proto</strong>有关 。</strong></p>\n<p>当我们「读取」 obj.toString 时，JS 引擎会做下面的事情：</p>\n<ul>\n<li>看看 obj 对象本身有没有 toString 属性。没有就走到下一步。</li>\n<li>看看 obj.<strong>proto</strong> 对象有没有 toString 属性， 发现 obj.<strong>proto</strong> 有 toString 属性， 于是找到了，所以 obj.toString 实际就是第 2 步中找到的 obj.<strong>proto</strong>.toString。</li>\n<li>如果 obj.<strong>proto</strong>没有，那么浏览器会继续查看 obj.<strong>proto</strong>.<strong>proto</strong></li>\n<li>如果 obj.<strong>proto</strong>.<strong>proto</strong>也没有，那么浏览器会继续查看 obj.<strong>proto</strong>.<strong>proto</strong>.<strong>proto</strong></li>\n<li>直到找到 toString 或者 <strong>proto</strong> 为 null。</li>\n</ul>\n<p>上面的过程，就是「读」属性的「搜索过程」。而这个「搜索过程」，是连着由 <strong>proto</strong> 组成的链子一直走的。<strong>这个链子，就叫做「原型链」。</strong></p>\n<h4>共享原型链</h4>\n<p>现在我们还有另一个对象</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj2 = { name: &quot;obj2&quot; };\n</code></pre><p>如图:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-03.png\" alt></p>\n<p>那么 obj.toString 和 obj2.toString 其实是同一东西， 也就是 obj2.<strong>proto</strong>.toString。</p>\n<p>说白了，我们改其中的一个 <strong>proto</strong>.toString ，那么另外一个其实也会变!</p>\n<h4>差异化</h4>\n<p>如果我们想让 obj.toString 和 obj2.toString 的行为不同怎么做呢？\n直接赋值就好了：</p>\n<pre class=\"prettyprint language-javascript\"><code>obj.toString = function() {\n    return &quot;新的 toString 方法&quot;;\n};\n</code></pre><p><img src=\"https://image.fundebug.com/2019-02-10-04.png\" alt></p>\n<p><strong>小结</strong></p>\n<ul>\n<li>[读]属性时会沿着原型链搜索</li>\n<li>[新增]属性时不会去看原型链</li>\n</ul>\n<h3>2. this 的值到底是什么</h3>\n<p>你可能遇到过这样的 JS 面试题：</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = {\n    foo: function() {\n        console.log(this);\n    }\n};\n\nvar bar = obj.foo;\nobj.foo(); &#x2F;&#x2F; 打印出的 this 是 obj\nbar(); &#x2F;&#x2F; 打印出的 this 是 window\n</code></pre><p>请解释最后两行函数的值为什么不一样。</p>\n<h4>函数调用</h4>\n<p>JS（ES5）里面有三种函数调用形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>func(p1, p2);\nobj.child.method(p1, p2);\nfunc.call(context, p1, p2); &#x2F;&#x2F; 先不讲 apply\n</code></pre><p>一般，初学者都知道前两种形式，而且认为前两种形式「优于」第三种形式。\n我们方方老师大姥说了，你一定要记住，第三种调用形式，才是正常调用形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>func.call(context, p1, p2);\n</code></pre><p>其他两种都是语法糖，可以等价地变为 call 形式：</p>\n<p>func(p1, p2)等价于 func.call(undefined, p1, p2);</p>\n<p>obj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2);</p>\n<p>至此我们的函数调用只有一种形式：</p>\n<pre class=\"prettyprint language-javascript\"><code>func.call(context, p1, p2);\n</code></pre><p><strong>这样，this 就好解释了</strong> this 就是上面 context。</p>\n<p>this 是你 call 一个函数时传的 context，由于你从来不用 call 形式的函数调用，所以你一直不知道。</p>\n<p>先看 func(p1, p2) 中的 this 如何确定：</p>\n<pre class=\"prettyprint language-javascript\"><code>当你写下面代码时;\n\nfunction func() {\n    console.log(this);\n}\n\nfunc();\n等价于;\n\nfunction func() {\n    console.log(this);\n}\n\nfunc.call(undefined); &#x2F;&#x2F; 可以简写为 func.call()\n</code></pre><p>按理说打印出来的 this 应该就是 undefined 了吧，但是浏览器里有一条规则：</p>\n<blockquote>\n<p>如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</p>\n</blockquote>\n<p>因此上面的打印结果是 window。如果你希望这里的 this 不是 window，很简单：</p>\n<pre class=\"prettyprint language-javascript\"><code>func.call(obj); &#x2F;&#x2F; 那么里面的 this 就是 obj 对象了\n</code></pre><p>回到题目：</p>\n<pre class=\"prettyprint language-javascript\"><code>var obj = {\n    foo: function() {\n        console.log(this);\n    }\n};\n\nvar bar = obj.foo;\nobj.foo(); &#x2F;&#x2F; 转换为 obj.foo.call(obj)，this 就是 obj\nbar();\n&#x2F;&#x2F; 转换为 bar.call()\n&#x2F;&#x2F; 由于没有传 context\n&#x2F;&#x2F; 所以 this 就是 undefined\n&#x2F;&#x2F; 最后浏览器给你一个默认的 this —— window 对象\n</code></pre><h4>[ ] 语法</h4>\n<pre class=\"prettyprint language-javascript\"><code>function fn() {\n    console.log(this);\n}\nvar arr = [fn, fn2];\narr[0](); &#x2F;&#x2F; 这里面的 this 又是什么呢？\n</code></pre><p>我们可以把 arr<a href=\"https://segmentfault.com/a/1190000016542417#\">0</a> 想象为 arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：</p>\n<pre class=\"prettyprint language-javascript\"><code>arr[0]();\n</code></pre><p>假想为 arr.0()\n然后转换为 arr.0.call(arr)\n那么里面的 this 就是 arr 了 :)</p>\n<p><strong>小结：</strong></p>\n<ul>\n<li>this 就是你 call 一个函数时，传入的第一个参数。</li>\n<li>如果你的函数调用不是 call 形式， 请将其转换为 call 形式</li>\n</ul>\n<p><strong>码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\">Fundebug</a>。</strong></p>\n<h3>3. JS 的 new 到底是干什么的？</h3>\n<p>我们声明一个士兵，具有如下属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>var 士兵 = {\n    ID: 1, &#x2F;&#x2F; 用于区分每个士兵\n    兵种: &quot;美国大兵&quot;,\n    攻击力: 5,\n    生命值: 42,\n    行走: function() {\n        &#x2F;*走俩步的代码*&#x2F;\n    },\n    奔跑: function() {\n        &#x2F;*狂奔的代码*&#x2F;\n    },\n    死亡: function() {\n        &#x2F;*Go die*&#x2F;\n    },\n    攻击: function() {\n        &#x2F;*糊他熊脸*&#x2F;\n    },\n    防御: function() {\n        &#x2F;*护脸*&#x2F;\n    }\n};\n</code></pre><p>我们制造一个士兵， 只需要这样：</p>\n<pre class=\"prettyprint language-javascript\"><code>兵营.制造(士兵);\n</code></pre><p>如果需要制造 100 个士兵怎么办呢？</p>\n<pre class=\"prettyprint language-javascript\"><code>循环 100 次吧：\n\nvar 士兵们 = []\nvar 士兵\nfor(var i=0; i&lt;100; i++){\n  士兵 = {\n    ID: i, &#x2F;&#x2F; ID 不能重复\n    兵种:&quot;美国大兵&quot;,\n    攻击力:5,\n    生命值:42,\n    行走:function(){ &#x2F;*走俩步的代码*&#x2F;}，\n    奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n    死亡:function(){ &#x2F;*Go die*&#x2F;    },\n    攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n    防御:function(){ &#x2F;*护脸*&#x2F;       }\n  }\n  士兵们.push(士兵)\n}\n\n兵营.批量制造(士兵们)\n</code></pre><p>哎呀，看起来好简单</p>\n<h4>质疑</h4>\n<p>上面的代码存在一个问题：浪费了很多内存</p>\n<ul>\n<li>行走、奔跑、死亡、攻击、防御这五个动作对于每个士兵其实是一样的，只需要各自引用同一个函数就可以了，没必要重复创建 100 个行走、100 个奔跑……</li>\n<li>这些士兵的兵种和攻击力都是一样的，没必要创建 100 次。</li>\n<li>只有 ID 和生命值需要创建 100 次，因为每个士兵有自己的 ID 和生命值。</li>\n</ul>\n<h4>改进</h4>\n<p>通过第一节可以知道 ，我们可以通过原型链来解决重复创建的问题：我们先创建一个「士兵原型」，然后让「士兵」的 <strong>proto</strong> 指向「士兵原型」。</p>\n<pre class=\"prettyprint language-javascript\"><code>var 士兵原型 = {\n  兵种:&quot;美国大兵&quot;,\n  攻击力:5,\n  行走:function(){ &#x2F;*走俩步的代码*&#x2F;}，\n  奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n  死亡:function(){ &#x2F;*Go die*&#x2F;    },\n  攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n  防御:function(){ &#x2F;*护脸*&#x2F;       }\n}\n\nvar 士兵们 = []\nvar 士兵\nfor(var i=0; i&lt;100; i++){\n  士兵 = {\n    ID: i, &#x2F;&#x2F; ID 不能重复\n    生命值:42\n  }\n\n  &#x2F;*实际工作中不要这样写，因为 __proto__ 不是标准属性*&#x2F;\n  士兵.__proto__ = 士兵原型\n\n  士兵们.push(士兵)\n}\n\n兵营.批量制造(士兵们)\n</code></pre><h4>优雅？</h4>\n<p>有人指出创建一个士兵的代码分散在两个地方很不优雅，于是我们用一个函数把这两部分联系起来：</p>\n<pre class=\"prettyprint language-javascript\"><code>function 士兵(ID){\n  var 临时对象 = {};\n  临时对象.__proto__ = 士兵.原型;\n  临时对象.ID = ID;\n  临时对象.生命值 = 42;\n\n  return 临时对象;\n}\n\n士兵.原型 = {\n  兵种:&quot;美国大兵&quot;,\n  攻击力:5,\n  行走:function(){ &#x2F;*走俩步的代码*&#x2F;}，\n  奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n  死亡:function(){ &#x2F;*Go die*&#x2F;    },\n  攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n  防御:function(){ &#x2F;*护脸*&#x2F;       }\n}\n\n&#x2F;&#x2F; 保存为文件：士兵.js\n\n 然后就可以愉快地引用「士兵」来创建士兵了：\n\nvar 士兵们 = []\nfor(var i=0; i&lt;100; i++){\n  士兵们.push(士兵(i))\n}\n\n兵营.批量制造(士兵们)\n</code></pre><p>JS 之父看到大家都这么搞，觉得何必呢，我给你们个糖吃，于是 JS 之父创建了 new 关键字，可以让我们少写几行代码：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-05.png\" alt></p>\n<p><strong>只要你在士兵前面使用 new 关键字，那么可以少做四件事情：</strong></p>\n<ol>\n<li>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）；</li>\n<li>不用绑定原型，因为 new 会帮你做(new 为了知道原型在哪，所以指定原型的名字 prototype);</li>\n<li>不用 return 临时对象，因为 new 会帮你做；</li>\n<li>不要给原型想名字了，因为 new 指定名字为 prototype。</li>\n</ol>\n<h4>这一次用 new 来写</h4>\n<pre class=\"prettyprint language-javascript\"><code>function 士兵(ID){\n  this.ID = ID\n  this.生命值 = 42\n}\n\n士兵.prototype = {\n  兵种:&quot;美国大兵&quot;,\n  攻击力:5,\n  行走:function(){ &#x2F;*走俩步的代码*&#x2F;},\n  奔跑:function(){ &#x2F;*狂奔的代码*&#x2F;  },\n  死亡:function(){ &#x2F;*Go die*&#x2F;    },\n  攻击:function(){ &#x2F;*糊他熊脸*&#x2F;   },\n  防御:function(){ &#x2F;*护脸*&#x2F;       }\n}\n\n&#x2F;&#x2F; 保存为文件：士兵.js\n然后是创建士兵（加了一个 new 关键字）：\n\nvar 士兵们 = []\nfor(var i=0; i&lt;100; i++){\n  士兵们.push(new 士兵(i))\n}\n\n兵营.批量制造(士兵们)\n</code></pre><p><strong>new 的作用，就是省那么几行代码。（也就是所谓的语法糖）</strong></p>\n<h4>注意 constructor 属性</h4>\n<p>new 操作为了记录「临时对象是由哪个函数创建的」，所以预先给「士兵.prototype」加了一个 constructor 属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>士兵.prototype = {\n    constructor: 士兵\n};\n</code></pre><p>如果你重新对「士兵.prototype」赋值，那么这个 constructor 属性就没了，所以你应该这么写：</p>\n<pre class=\"prettyprint language-javascript\"><code>士兵.prototype.兵种 = &quot;美国大兵&quot;;\n士兵.prototype.攻击力 = 5;\n士兵.prototype.行走 = function() {\n    &#x2F;*走俩步的代码*&#x2F;\n};\n士兵.prototype.奔跑 = function() {\n    &#x2F;*狂奔的代码*&#x2F;\n};\n士兵.prototype.死亡 = function() {\n    &#x2F;*Go die*&#x2F;\n};\n士兵.prototype.攻击 = function() {\n    &#x2F;*糊他熊脸*&#x2F;\n};\n士兵.prototype.防御 = function() {\n    &#x2F;*护脸*&#x2F;\n};\n</code></pre><p>或者你也可以自己给 constructor 重新赋值：</p>\n<pre class=\"prettyprint language-javascript\"><code>士兵.prototype = {\n    constructor: 士兵,\n    兵种: &quot;美国大兵&quot;,\n    攻击力: 5,\n    行走: function() {\n        &#x2F;*走俩步的代码*&#x2F;\n    },\n    奔跑: function() {\n        &#x2F;*狂奔的代码*&#x2F;\n    },\n    死亡: function() {\n        &#x2F;*Go die*&#x2F;\n    },\n    攻击: function() {\n        &#x2F;*糊他熊脸*&#x2F;\n    },\n    防御: function() {\n        &#x2F;*护脸*&#x2F;\n    }\n};\n</code></pre><h3>四、继承</h3>\n<p><strong>继承的本质就是上面的讲的原型链</strong></p>\n<h4>1)借助构造函数实现继承</h4>\n<pre class=\"prettyprint language-javascript\"><code>function Parent1() {\n    this.name = &quot;parent1&quot;;\n}\n\nParent1.prototype.say = function() {};\n\nfunction Child1() {\n    Parent1.call(this);\n    this.type = &quot;child&quot;;\n}\n\nconsole.log(new Child1());\n</code></pre><p>打印结果：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-06.png\" alt></p>\n<p>这个主要是借用 call 来改变 this 的指向，通过 call 调用 Parent ，此时 Parent 中的 this 是指 Child1。有个缺点，从打印结果看出 Child1 并没有 say 方法，所以这种只能继承父类的实例属性和方法，不能继承原型属性/方法。</p>\n<h4>2)借助原型链实现继承</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 借助原型链实现继承\n *&#x2F;\nfunction Parent2() {\n    this.name = &quot;parent2&quot;;\n    this.play = [1, 2, 3];\n}\n\nfunction Child2() {\n    this.type = &quot;child2&quot;;\n}\nChild2.prototype = new Parent2();\n\nconsole.log(new Child2());\n\nvar s1 = new Child2();\nvar s2 = new Child2();\n</code></pre><p>打印：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-07.png\" alt></p>\n<p>通过一讲的，我们知道要共享莫些属性，需要 对象.<strong>proto</strong> = 父亲对象的.prototype,但实际上我们是不能直接 操作<strong>proto</strong>，这时我们可以借用 new 来做，所以\nChild2.prototype = new Parent2(); &lt;=&gt; Child2.prototype.<strong>proto</strong> = Parent2.prototype; 这样我们借助 new 这个语法糖，就可以实现原型链继承。但这里有个总是，如打印结果，我们给 s1.play 新增一个值 ，s2 也跟着改了。所以这个是原型链继承的缺点，原因是 s1.<strong>pro</strong> 和 s2.<strong>pro</strong>指向同一个地址即 父类的 prototype。</p>\n<h4>3)组合方式实现继承</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 组合方式\n *&#x2F;\n\nfunction Parent3() {\n    this.name = &quot;parent3&quot;;\n    this.play = [1, 2, 3];\n}\n\nParent3.prototype.say = function() {};\n\nfunction Child3() {\n    Parent3.call(this);\n    this.type = &quot;child3&quot;;\n}\n\nChild3.prototype = new Parent3();\n\nvar s3 = new Child3();\nvar s4 = new Child3();\ns3.play.push(4);\nconsole.log(new Child3());\nconsole.log(s3.play, s4.play);\n</code></pre><p>打印:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-08.png\" alt></p>\n<p>将 1 和 2 两种方式组合起来，就可以解决 1 和 2 存在问题，这种方式为组合继承。这种方式有点缺点就是我实例一个对象的时， 父类 new 了两次，一次是 var s3 = new Child3()对应 Child3.prototype = new Parent3()还要 new 一次。</p>\n<h4>4)组合继承的优化 1</h4>\n<pre class=\"prettyprint language-javascript\"><code>function Parent4() {\n    this.name = &quot;parent4&quot;;\n    this.play = [1, 2, 3];\n}\n\nParent4.prototype.say = function() {};\n\nfunction Child4() {\n    Parent4.call(this);\n    this.type = &quot;child4&quot;;\n}\n\nChild4.prototype = Parent4.prototype;\n\nvar s5 = new Child4();\nvar s6 = new Child4();\n</code></pre><p>这边主要为 Child4.prototype = Parent4.prototype， 因为我们通过构造函数就可以拿到所有属性和实例的方法，那么现在我想继承父类的原型对象，所以你直接赋值给我就行，不用在去 new 一次父类。其实这种方法还是有问题的，如果我在控制台打印以下两句:</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-09.png\" alt></p>\n<p>从打印可以看出，此时我是没有办法区分一个对象 是直接 由它的子类实例化还是父类呢？我们还有一个方法判断来判断对象是否是类的实例，那就是用 constructor,我在控制台打印以下内容：</p>\n<p><img src=\"https://image.fundebug.com/2019-02-10-10.png\" alt></p>\n<p>咦，你会发现它指向的是父类 ，这显然不是我们想要的结果， 上面讲过我们 prototype 里面有一个 constructor, 而我们此时子类的 prototype 指向是 父类的 prototye ,而父类 prototype 里面的 contructor 当然是父类自己的，这个就是产生该问题的原因。</p>\n<h4>组合继承的优化 2</h4>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 组合继承的优化2\n *&#x2F;\n\nfunction Parent5() {\n    this.name = &quot;parent4&quot;;\n    this.play = [1, 2, 3];\n}\n\nParent5.prototype.say = function() {};\n\nfunction Child5() {\n    Parent5.call(this);\n    this.type = &quot;child4&quot;;\n}\n\nChild5.prototype = Object.create(Parent5.prototype);\n</code></pre><p>这里主要使用<strong>Object.create()</strong>，它的作用是将对象继承到<strong>proto</strong>属性上。举个例子：</p>\n<pre class=\"prettyprint language-javascript\"><code>var test = Object.create({ x: 123, y: 345 });\nconsole.log(test); &#x2F;&#x2F;{}\nconsole.log(test.x); &#x2F;&#x2F;123\nconsole.log(test.__proto__.x); &#x2F;&#x2F;3\nconsole.log(test.__proto__.x === test.x); &#x2F;&#x2F;true\n</code></pre><p>那大家可能说这样解决了吗，其实没有解决,因为这时 Child5.prototype 还是没有自己的 constructor,它要找的话还是向自己的原型对象上找最后还是找到 Parent5.prototype, constructor 还是 Parent5 ,所以要给 Child5.prototype 写自己的 constructor:</p>\n<pre class=\"prettyprint language-javascript\"><code>Child5.prototype = Object.create(Parent5.prototype);\nChild5.prototype.constructor = Child5;\n</code></pre><h4>参考</h4>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23090041?refer=study-fe\">什么是 JS 原型链？</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23804247\">this 的值到底是什么？一次说清楚</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/23987456?refer=study-fe\">JS 的 new 到底是干什么的？</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java线上应用实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了10亿+错误事件，付费客户有Google、360、金山软件、百姓网等众多品牌企业。欢迎大家<a href=\"https://www.fundebug.com/team/create\">免费试用</a>！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n</div>","title":"搞懂 JavaScript 继承原理","last_reply_at":"2019-02-21T03:46:03.807Z","good":false,"top":false,"reply_count":5,"visit_count":823,"create_at":"2019-02-11T02:42:14.469Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c2190c176c4964062a1d641","author_id":"58d140302c8bf2a836456213","tab":"share","content":"<div class=\"markdown-text\"><p><strong>摘要：</strong> 对JSer来说，这是很有意思的1年。</p>\n<p>本文灵感来自<a href=\"https://javascriptweekly.com/\">JavaScript Weekly</a>周报，欢迎大家订阅。</p>\n<h3>The State of JavaScript 2018</h3>\n<p><a href=\"https://2018.stateofjs.com/\">The State of JavaScript</a>调研已经连续做了3年(<a href=\"http://2016.stateofjs.com/\">2016</a>, <a href=\"https://2017.stateofjs.com/\">2017</a>, <a href=\"https://2018.stateofjs.com\">2018</a>)，<a href=\"https://2018.stateofjs.com/\">今年</a>一共调研了2万多个JS开发者。有这样一些有意思的发现：</p>\n<ul>\n<li>绝大多数开发者都用过ES6，同时TypeScript也越来越流行了；</li>\n<li>React依然最流行的前端框架，同时Vue也越来越受欢迎了；</li>\n<li>Express依然是最流行的Node.js框架(Node 8已经支持async函数了，Koa的价值应该少了很多)；</li>\n<li>Visual Studio code远远超越Sublime，成为最流行的JS编辑器；</li>\n</ul>\n<p>作为一个后端用Express框架，尽量使用最新的ECMAScript语法，而前端用着TypeScript，不过框架还是AngularJS 1(这事要怪版本帝Angular不向后兼容)，抛弃价值70刀的Sublime，今年加入VS code阵营的JSer，我也是算是够主流了吧！那你呢？</p>\n<h3>ECMAScript 2018</h3>\n<p>TC39(ECMAScript标准委员会)这些年越来越勤快了，从2015年(ES6)开始，每年发布一个新的ECMAScipt标准。今年大佬们继续忙于处理各种<a href=\"https://github.com/tc39/proposals\">proposal</a>。<a href=\"https://www.ecma-international.org/publications/standards/Ecma-262.htm\">ECMAScript 2018</a>，即ES9，则在6月如期发布了，其新增的特性并不多：</p>\n<p><strong>主要新特性:</strong></p>\n<ul>\n<li><a href=\"http://2ality.com/2016/10/asynchronous-iteration.html\">Asynchronous Iteration</a></li>\n<li><a href=\"http://2ality.com/2016/10/rest-spread-properties.html\">Rest/Spread Properties</a></li>\n</ul>\n<p><strong>新的正则表达式特性</strong>:</p>\n<ul>\n<li><a href=\"http://2ality.com/2017/05/regexp-named-capture-groups.html\">RegExp named capture groups</a></li>\n<li><a href=\"http://2ality.com/2017/07/regexp-unicode-property-escapes.html\">RegExp Unicode Property Escapes</a></li>\n<li><a href=\"http://2ality.com/2017/05/regexp-lookbehind-assertions.html\">RegExp Lookbehind Assertions</a></li>\n<li><a href=\"http://2ality.com/2017/07/regexp-dotall-flag.html\"><code>s</code> (<code>dotAll</code>) flag for regular expressions</a></li>\n</ul>\n<p><strong>其他新特性</strong>:</p>\n<ul>\n<li><a href=\"http://2ality.com/2017/07/promise-prototype-finally.html\"><code>Promise.prototype.finally()</code></a></li>\n<li><a href=\"http://2ality.com/2016/09/template-literal-revision.html\">Template Literal Revision</a></li>\n</ul>\n<p>如果想了解ES9的细节，阔以看看<a href=\"http://dr-axel.de/\">Axel Rauschmayer</a>博士写的<a href=\"http://exploringjs.com/es2018-es2019/toc.html\">Exploring ES2018 and ES2019</a>。</p>\n<h3>Node 10</h3>\n<p>Node 10在4月<a href=\"https://nodejs.org/en/blog/release/v10.0.0/\">发布</a>并且在10月成为<a href=\"https://medium.com/%5B@nodejs%5D(/user/nodejs)/october-brings-node-js-10-x-to-lts-and-node-js-11-to-current-ae19f8f12b51\">LTS</a>，即长期支持版本。</p>\n<p>Node 10使用了新的<a href=\"https://v8.dev/\">V8引擎</a>6.8，因此性能提升了很多，比如<a href=\"https://v8.dev/blog/fast-async\">Promise与Async函数的性能提升就非常明显</a>，因此建议大家升级。</p>\n<p>Node新版本的<a href=\"https://github.com/nodejs/release\">发布日期</a>一直非常稳定，做到这一点也是不容易啊！</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-node.png\" alt></p>\n<h3>Vue 3.0</h3>\n<p>在<a href=\"https://vuetoronto.com/\">Vue.js Conference Toronto 2018</a>上，尤雨溪发表了主题演讲<a href=\"https://docs.google.com/presentation/d/1yhPGyhQrJcpJI2ZFvBme3pGKaGNiLi709c37svivv0o/edit#slide=id.p\">Vue 3.0 Updates</a>，新版本将会有这些变化：</p>\n<ul>\n<li>更快</li>\n<li>更小</li>\n<li>更易于维护</li>\n<li>更多的原生支持</li>\n<li><a href=\"https://www.zhihu.com/question/46397274/answer/101193678\">放弃Flow，使用TypeScript</a></li>\n</ul>\n<p>Vue 3.0<a href=\"https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf\">预计将在2019发布</a>，大家期待吧！</p>\n<h3>Babel 7</h3>\n<p>2年多时间commit了4000多次，<a href=\"https://babeljs.io/blog/2018/08/27/7.0.0\">Babel 7终于发布了</a>，新增了下面这些特性：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/babel-upgrade\">babel-upgrade</a>: 升级Babel的工具；</li>\n<li><a href=\"https://babeljs.io/docs/en/next/config-files#project-wide-configuration\">babel.config.js</a>：学习ESLint与Webpack，使用JS文件配置；</li>\n<li><a href=\"https://babeljs.io/docs/en/options#overrides\">overrides</a>：允许同一个项目使用不同的Babel配置，例如前端代码的targets为Chrome 60，而后端代码的targets为Node 8；</li>\n<li>…</li>\n</ul>\n<p><img src=\"https://image.fundebug.com/2018-12-24-babel.png\" alt></p>\n<p>主流浏览器对新的ECMAScript特性已经支持得不错了，不过还是存在并且永远存在很多非主流浏览器，于是我们还是离不开神奇的Babel。</p>\n<h3>jQuery 3.3.0</h3>\n<p>曾经风靡一时的<a href=\"http://blog.jquery.com/2018/01/19/jquery-3-3-0-a-fragrant-bouquet-of-deprecations-and-is-that-a-new-feature/\">jQuery发布了3.3.0</a>，这个版本放弃了(deprecated)一系列方法：</p>\n<ul>\n<li>jQuery.now</li>\n<li>jQuery.isWindow</li>\n<li>jQuery.camelCase</li>\n<li>jQuery.proxy</li>\n<li>jQuery.type</li>\n<li>jQuery.isNumeric</li>\n<li>jQuery.isFunction</li>\n<li>Event aliases</li>\n</ul>\n<p>这些方法大多会在jQuery 4.0中被删除，因此jQuery官方鼓励大家使用替代的方法。</p>\n<p>从这个更新也能看出端倪，jQuery时代已经逐渐过去了，<a href=\"https://githubengineering.com/removing-jquery-from-github-frontend/\">GitHub的极客们干脆完全抛弃了jQuery</a>。</p>\n<h3>V8引擎10周年</h3>\n<p>强大的<a href=\"https://v8.dev/blog/10-years\">V8引擎已经发布10周年了</a>，它的命名灵感来自超级性能车的V8引擎，果然名副其实！其性能一直稳步提高：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-v8.png\" alt></p>\n<p>V8引擎当初是为Chrome浏览器开发的，但是早已成为一个独立的项目。国内的众多浏览器，包括搜狗、360、猎豹、QQ、百度、UC都是基于<a href=\"https://zh.wikipedia.org/wiki/Chromium\">Chromium</a>浏览器开发，而Chromium相当于开源版本的Chrome，自然也是基于V8引擎的。因此，众多&quot;国产&quot;浏览器实际上都是基于V8的。融资了2.5亿元红芯浏览器也不例外，<a href=\"https://www.pingwest.com/a/176061\">他们干脆打包了Chrome浏览器的安装包</a>，果然有钱任性！还有，就连浏览器界的一朵奇葩<a href=\"https://www.ifanr.com/1138933\">Microsoft也投靠了Chromium阵营</a>。</p>\n<p>另外，Node.js也是基于V8引擎的。</p>\n<h3>NPM模块<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>被黑客攻击</h3>\n<p>这件事闹得沸沸扬扬，不过只是有很多噱头，如果<a href=\"https://blog.fundebug.com/2018/12/03/how-does-javascript-hacker-steal-bitcoin/\">认真分析黑客干了什么</a>，其真实影响没那么大，至少Vue开发者没啥好担心的：</p>\n<ul>\n<li>比特币钱包<a href=\"https://github.com/bitpay/copay\">copay</a>依赖<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块；</li>\n<li>黑客从骗取了<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块的npm发布权限；</li>\n<li>黑客为<a href=\"https://github.com/dominictarr/event-stream\">event-stream</a>模块添加了依赖<a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>；</li>\n<li><a href=\"https://www.npmjs.com/package/flatmap-stream\">flatmap-stream</a>含有黑客代码，仅会在<a href=\"https://github.com/bitpay/copay\">copay</a>项目中正确执行，窃取用户的密码、私钥等信息，从而盗取比特币；</li>\n<li>有人说什么Vue可能遭受攻击，其实没有这回事，因为黑客代码只会在<a href=\"https://github.com/bitpay/copay\">copay</a>项目中正确执行。只有<a href=\"https://github.com/bitpay/copay\">copay</a>项目的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json\">package.json</a>中的<a href=\"https://github.com/bitpay/copay/blob/cd3f2b380588e6bc90e6c498bf9ae075bcc59e34/package.json#L3\">description</a>字符串&quot;A Secure Bitcoin Wallet&quot;能够解密黑客代码；而且，黑客的代码是为<a href=\"https://github.com/bitpay/copay\">copay</a>量身定做的，对其他项目没有作用；再说，黑客是来窃取的比特币的，又不是挖矿，你的项目有比特币给人家偷吗?</li>\n</ul>\n<p>同学们，不要被标题党给骗了啊！</p>\n<h3>《Refactoring》第2版改用JavaScript</h3>\n<p><a href=\"https://book.douban.com/subject/1229923/\">《重构：改善既有代码的设计》</a>大多数人都没看过，但是至少应该都听过。这本书刚出了<a href=\"https://www.amazon.com/gp/product/0134757599\">第二版</a>，所有示例代码由Java改成了JavaScript。</p>\n<p>根据作者<a href=\"https://martinfowler.com/articles/refactoring-2nd-ed.html\">Martin Fowler</a>的<a href=\"https://martinfowler.com/articles/refactoring-2nd-ed.html\">解释</a>，**《重构》这本书重点在于思想，适用于各种编程语言，所以选择什么语言并不重要。**而他选择JavaScript的原因很简单，因为JS既支持面向过程编程，又支持面向对象编程，这样方便写非OOP代码重构的示例。</p>\n<p>这里不妨引用<a href=\"https://www.zhihu.com/question/46397274/answer/101193678\">尤雨溪</a>的一句话：</p>\n<blockquote>\n<p>至于重构、设计什么的，我只想说，看的是使用的人的水平，跟用什么语言没那么大关系。水平烂的人用 TS 一样写的是翔一样的代码，看看 java 就知道了。</p>\n</blockquote>\n<p>《Refactoring》的示例代码用什么语言写根本不重要，重要的是背后的编程思想。顺便推荐一下《Clean Code》。</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-refactoring.jpg\" alt></p>\n<p>这本书原价54.66刀，的确有点贵，不过算是必读书，大家看着办…</p>\n<h3>GitHub抛弃jQuery</h3>\n<p>一直以来，GitHub最流行的编程语言都是JavaScript，可以说GitHub是全球最大的JS开发者社交平台了；同时，因为被IE的兼容问题折磨了多年，前端痛恨Microsoft！但是，有钱任性的Microsoft以75亿美元收购了GitHub！</p>\n<p>另外，<a href=\"https://githubengineering.com/removing-jquery-from-github-frontend/\">GitHub的技术极客们花了数年时间，以非常规范的流程完全移除GitHub网站了jQuery</a>：</p>\n<ul>\n<li>实现了一个ESlint插件<a href=\"https://github.com/dgraham/eslint-plugin-jquery\">eslint-plugin-jquery</a>，禁止在代码中使用已经弃用的jQuery方法。这样可以防止同事使用jQuery方法。</li>\n<li>使用原生代码重写了2个依赖于jQuery的模块<a href=\"https://github.com/defunkt/jquery-pjax\">jquery-pjax</a>和<a href=\"https://github.com/defunkt/facebox\">facebox</a>。</li>\n<li>开发一个定制的jQuery版本，一旦完全移除某个jQuery方法，就删除jQuery中的对应代码。这样既可以减少jQuery大小，也可以防止同事使用已经移除的jQuery方法。</li>\n<li>根据用户统计数据，来逐步放弃支持低版本的IE浏览器，这样的话可以无需依赖jQuery来保证兼容性。</li>\n<li>…</li>\n</ul>\n<p>是否使用jQuery各有各的想法和需求，但是<strong>GitHub弃用jQuery的流程非常专业，可以作为处理技术债的标准规范</strong>。</p>\n<h3>Microsoft爱上JavaScript</h3>\n<p>土豪Microsoft似乎爱上了JavaScript，它家的<a href=\"https://www.reddit.com/r/programming/comments/8qqhlz/comment/e0ll1dt/\">Office 365, MicroSoft Teams以及Skype都开始使用JavaScript重写了</a>。原因无疑是JS的跨平台特性。同一套代码多处运行，虽然现在还有很多问题，但是这样的未来不是挺好么？</p>\n<p>此处应该再来感受一下大名鼎鼎的<a href=\"https://blog.codinghorror.com/the-principle-of-least-power/\">Atwood’s Law</a>：</p>\n<blockquote>\n<p>Any application that can be written in JavaScript, will eventually be written in JavaScript</p>\n</blockquote>\n<p>在浏览器市场上，Microsoft曾经通过捆绑Windows打败了网景，不过这些年在Chrome面前一败涂地，现在终于&quot;认输&quot;，选择<a href=\"https://www.ifanr.com/1138933\">基于Chromium重写浏览器</a>。对于JSer来说，至少意味着浏览器兼容问题可以缓解很多。</p>\n<p>根据<a href=\"https://2018.stateofjs.com/other-tools/\">The State of JavaScript 2018</a>，Microsoft开发的<a href=\"https://code.visualstudio.com/\">Visual Studio code</a>俨然已经成为最受JSer欢迎的代码编辑器，一些流行插件下载量高达上千万：</p>\n<p><img src=\"https://image.fundebug.com/2018-12-24-vscode.png\" alt></p>\n<p>市值超过Apple，重回全球市值最高公司的Microsoft有钱任性，买下了JS开发者最多的GitHub。</p>\n<p>IT界的罗马帝国(出处：吴军《浪潮之巅》)Microsoft又重新崛起了，这是一件很了不起的事情。</p>\n<h3>Oracle宣示JavaScript主权</h3>\n<p><a href=\"https://mp.weixin.qq.com/s/gRtOaTXdLYVrIPnejVytMw\">Oracle明年就要开始给Java收费</a>，虽然只是JDK 8的u192之后的更新要收费，这个行为大概会让很多Java开发者不爽…</p>\n<p>另外，<a href=\"https://mp.weixin.qq.com/s/Q5bK8qHgLRzTsrA3NdC9wQ?\">Oracle还要求一个iOS开发者将一款叫做”HTML5, CSS, JavaScript, HTML, Snippet Editor“的App从App Store下架</a>，因为App名字中包含“JavaScript”字眼，而Oracle拥有JavaScript在美国的商标权。</p>\n<p>Oracle这位大爷惹不起，因此大家正在一本正经地<a href=\"https://www.techrepublic.com/article/why-its-finally-time-to-give-up-on-the-name-javascript/\">建议给JavaScript改名</a>。当然这基本上是不可能的，这辈子都不可能。。。</p>\n<h3>参考</h3>\n<ul>\n<li><a href=\"https://blog.fundebug.com/2018/12/03/how-does-javascript-hacker-steal-bitcoin/\">JavaScript黑客是这样窃取比特币的，Vue开发者不用担心！</a></li>\n<li><a href=\"https://blog.fundebug.com/2018/11/28/10-english-technolody-newsletter/\">强烈推荐10个值得订阅的国外技术周报</a></li>\n<li><a href=\"https://blog.fundebug.com/2018/08/10/ecmascript-2018/\">ECMAScript 2018特性确定了</a></li>\n</ul>\n<h3>关于Fundebug</h3>\n<p><a href=\"https://www.fundebug.com/\">Fundebug</a>专注于JavaScript、微信小程序、微信小游戏、支付宝小程序、React Native、Node.js和Java实时BUG监控。 自从2016年双十一正式上线，Fundebug累计处理了9亿+错误事件，得到了Google、360、金山软件、百姓网等众多知名用户的认可。欢迎免费试用！</p>\n<p><img src=\"https://static.fundebug.cn/wechat_slogan.png\" alt></p>\n<h3>版权声明</h3>\n<p>转载时请注明作者<a href=\"https://www.fundebug.com/\">Fundebug</a>以及本文地址：\n<a href=\"https://blog.fundebug.com/2018/12/25/what-happens-in-2018-for-javascript/\">https://blog.fundebug.com/2018/12/25/what-happens-in-2018-for-javascript/</a></p>\n</div>","title":"2018年，JavaScript都经历了什么？","last_reply_at":"2019-02-21T03:27:48.960Z","good":true,"top":false,"reply_count":13,"visit_count":2779,"create_at":"2018-12-25T02:06:57.767Z","author":{"loginname":"Fundebug","avatar_url":"https://avatars2.githubusercontent.com/u/26496557?v=4&s=120"}},{"id":"5c6e13a033b0b629ac843988","author_id":"5c6e123833b0b629ac84396b","tab":"share","content":"<div class=\"markdown-text\"><p>官方文档 <a href=\"https://linkorg.club/#/view/button\">https://linkorg.club/#/view/button</a></p>\n</div>","title":"vue2.x UI 组件，包含校验输入框，tip文字提示框，按钮，switch开关，ip子网掩码输入框，更新。。。","last_reply_at":"2019-02-21T02:57:36.728Z","good":false,"top":false,"reply_count":0,"visit_count":254,"create_at":"2019-02-21T02:57:36.728Z","author":{"loginname":"Linkontoask","avatar_url":"https://avatars1.githubusercontent.com/u/26475695?v=4&s=120"}},{"id":"5c6cc666e1a81129a7ad88b6","author_id":"5c024ab7887c5864fafe1804","tab":"ask","content":"<div class=\"markdown-text\"><p>背景:因为vue-cli更新3.x了，所以想把2.x版本删除\n是用yarn global add vue-cli@2.x 的\n在我卸载掉2.x版本后，yarn的全局bin目录下多出了好多.cmd文件\n原本只有使用yarn global add xxx 安装的包的名字.cmd文件\n对于强迫症来说有点难受\n另外是不是有可能会覆盖命令，\n举一个例子，我电脑有java环境，正常情况下在powershell输入java是java环境的一些输出，如果yarn的bin目录下也有一个叫java的，是不是会冲突</p>\n</div>","title":"yarn global remove 的 问题","last_reply_at":"2019-02-21T02:50:46.231Z","good":false,"top":false,"reply_count":1,"visit_count":244,"create_at":"2019-02-20T03:15:50.189Z","author":{"loginname":"1124219777","avatar_url":"https://avatars2.githubusercontent.com/u/17058939?v=4&s=120"}},{"id":"5c6ab1b6ed5543510be8cbe0","author_id":"5a9d2f0989a57ad544fa4279","tab":"share","content":"<div class=\"markdown-text\"><p><a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/43\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/43</a> 事件循环总览\n<a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/44\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/44</a> setTimeout, setImmediate, nextTick\n<a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/45\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/45</a> promises,nexttick 与 immediate\n<a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/46\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/46</a> IO 处理\n<a href=\"https://github.com/zhangxiang958/zhangxiang958.github.io/issues/47\">https://github.com/zhangxiang958/zhangxiang958.github.io/issues/47</a> 最佳实践</p>\n</div>","title":"翻译了一个关于事件循环的系列博文，请大家多多指教","last_reply_at":"2019-02-21T02:27:21.175Z","good":false,"top":false,"reply_count":3,"visit_count":536,"create_at":"2019-02-18T13:23:02.531Z","author":{"loginname":"zhangxiang958","avatar_url":"https://avatars1.githubusercontent.com/u/13307374?v=4&s=120"}},{"id":"5c57980805cc322e7b1373ab","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><ul>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/love/dist/\">爱心闪烁效果</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/ballline/dist/\">简单的离子效果</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/simple_fireworks/dist/\">简单的烟花效果</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/simple_image_edit/dist/\">canvas实现图片裁切</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/BiuBiuBiu/dist/\">canvas射激光</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/paopao/dist/\">canvas实现鼠标跟踪动画</a></li>\n<li><a href=\"http://canvas.bengbuzhangyue.xyz/3d/dist/\">canvas实现3D文字</a></li>\n</ul>\n</div>","title":"最近学习canvas，做了一些效果的合集","last_reply_at":"2019-02-21T02:08:18.145Z","good":false,"top":false,"reply_count":14,"visit_count":1898,"create_at":"2019-02-04T01:40:24.214Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}},{"id":"5c6ddfb5e1a81129a7ad8f1a","author_id":"550973933135610a365b01fa","tab":"share","content":"<div class=\"markdown-text\"><h4>闲暇之余，将antd-pro项目的状态管理全部迁移到cc，欢迎大家尝鲜体验cc带来的全新体验，<a href=\"https://github.com/fantasticsoul/rcc-antd-pro\">项目地址</a></h4>\n<h4>快速预览</h4>\n<ul>\n<li><code>git clone https://github.com/fantasticsoul/rcc-antd-pro</code></li>\n<li><code>cd rcc-antd-pro</code></li>\n<li><code>npm i</code></li>\n<li><code>npm start</code></li>\n</ul>\n<h4><a href=\"https://juejin.im/post/5c39d15f6fb9a049e0639068\">react-control-center是什么</a></h4>\n</div>","title":"ant-design-pro powered by react-control-center","last_reply_at":"2019-02-21T02:05:59.487Z","good":false,"top":false,"reply_count":0,"visit_count":223,"create_at":"2019-02-20T23:16:05.442Z","author":{"loginname":"fantasticsoul","avatar_url":"https://avatars0.githubusercontent.com/u/7334950?v=4&s=120"}},{"id":"5c6d3191e1a81129a7ad8d2e","author_id":"5c4735a23b948a2b4ab70945","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"//static.cnodejs.org/FlPrSPQFN6_4OPWH9VXoom3pKToP\" alt=\"11111.jpg\">\n精英版8天nodejs培训视频教程，附带案例源码\n讲的很详细，分享出去，希望大家少走弯路，花更少的时间学习更多东西\n教程下载：<a href=\"https://www.sucaihuo.com/video/255.html\">https://www.sucaihuo.com/video/255.html</a></p>\n</div>","title":"精英版8天nodejs培训视频教程","last_reply_at":"2019-02-20T10:53:05.469Z","good":false,"top":false,"reply_count":0,"visit_count":366,"create_at":"2019-02-20T10:53:05.469Z","author":{"loginname":"jtghaha","avatar_url":"https://avatars0.githubusercontent.com/u/46346950?v=4&s=120"}},{"id":"5c6bce08b8913c5110b0c6b4","author_id":"5ac77987e34737560fccaa7b","tab":"share","content":"<div class=\"markdown-text\"><p><img src=\"https://i.loli.net/2019/02/19/5c6bcdd0355f4.png\" alt=\"image\"></p>\n<p><a href=\"https://github.com/BengBu-YueZhang/javascript-algorithms\">https://github.com/BengBu-YueZhang/javascript-algorithms</a></p>\n<p>写的比较low</p>\n</div>","title":"javascript用来解决的leetcode~~~~","last_reply_at":"2019-02-20T05:57:26.317Z","good":false,"top":false,"reply_count":6,"visit_count":436,"create_at":"2019-02-19T09:36:08.232Z","author":{"loginname":"BengBu-YueZhang","avatar_url":"https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"}}]}